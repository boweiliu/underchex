<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Underchex WASM Demo</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
        }
        h1 { color: #00d9ff; }
        .board-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        #board {
            position: relative;
            width: 500px;
            height: 500px;
        }
        .hex {
            position: absolute;
            width: 50px;
            height: 58px;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: transform 0.1s;
        }
        .hex:hover {
            transform: scale(1.1);
            z-index: 10;
        }
        .hex.color-0 { background: #2d3748; }
        .hex.color-1 { background: #4a5568; }
        .hex.color-2 { background: #718096; }
        .hex.selected { box-shadow: 0 0 0 3px #00ff88; }
        .hex.legal-move { box-shadow: 0 0 0 3px #00d9ff; }
        .hex.legal-capture { box-shadow: 0 0 0 3px #ff6b6b; }
        .piece { font-size: 28px; user-select: none; }
        .piece.white { filter: drop-shadow(0 0 2px #fff); }
        .piece.black { filter: drop-shadow(0 0 2px #000); }
        #info {
            background: #16213e;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }
        #moves-list {
            max-height: 200px;
            overflow-y: auto;
            background: #0f0f23;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
        }
        .status { font-size: 18px; font-weight: bold; }
        .status.check { color: #ff6b6b; }
        button {
            background: #00d9ff;
            color: #000;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
        }
        button:hover { background: #00b8e6; }
        button:disabled { background: #555; color: #888; cursor: not-allowed; }
        select {
            background: #16213e;
            color: #eee;
            border: 1px solid #00d9ff;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            margin: 5px;
        }
        .ai-section {
            margin-top: 15px;
            padding: 15px;
            background: #0f0f23;
            border-radius: 8px;
        }
        .ai-section h3 { margin-top: 0; color: #00d9ff; }
        .eval-bar {
            width: 100%;
            height: 20px;
            background: linear-gradient(to right, #333 50%, #666 50%);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            margin: 10px 0;
        }
        .eval-fill {
            height: 100%;
            background: #00d9ff;
            transition: width 0.3s ease;
        }
        .eval-text {
            position: absolute;
            width: 100%;
            text-align: center;
            line-height: 20px;
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 0 0 2px #000;
        }
        .thinking { animation: pulse 1s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    </style>
</head>
<body>
    <h1>Underchex - Rust/WASM Demo</h1>
    <p>Hexagonal chess variant running on WebAssembly</p>
    
    <div class="board-container">
        <div id="board"></div>
    </div>
    
    <div id="info">
        <p class="status" id="status">Loading WASM...</p>
        <p>Turn: <span id="turn">-</span> | Move: <span id="move-num">-</span></p>
        <button onclick="newGame()">New Game</button>
        <button onclick="resign()">Resign</button>
        
        <div class="ai-section">
            <h3>AI Controls</h3>
            <label>Difficulty: </label>
            <select id="ai-difficulty">
                <option value="easy">Easy (Depth 2)</option>
                <option value="medium" selected>Medium (Depth 4)</option>
                <option value="hard">Hard (Depth 6)</option>
            </select>
            <br><br>
            <button id="ai-move-btn" onclick="makeAIMove()">AI Move</button>
            <button id="ai-hint-btn" onclick="getAIHint()">Get Hint</button>
            <button onclick="toggleAutoPlay()">Auto-Play AI</button>
            <p id="ai-status"></p>
            <div>
                <label>Evaluation: </label>
                <div class="eval-bar">
                    <div class="eval-fill" id="eval-fill"></div>
                    <div class="eval-text" id="eval-text">0.00</div>
                </div>
            </div>
        </div>
        
        <h3>Move History</h3>
        <div id="moves-list"></div>
    </div>

    <script type="module">
        import init, { WasmGame, wasm_get_all_cells, wasm_is_valid_cell } from './pkg/underchex_wasm.js';

        let game;
        let selectedCell = null;
        let legalMoves = [];
        let autoPlayInterval = null;

        // Piece unicode symbols
        const PIECE_SYMBOLS = {
            King: { white: '♔', black: '♚' },
            Queen: { white: '♕', black: '♛' },
            Chariot: { white: '♖', black: '♜' },
            Lance: { white: '♗', black: '♝' },
            Knight: { white: '♘', black: '♞' },
            Pawn: { white: '♙', black: '♟' },
        };

        // Convert axial coords to screen position
        function hexToPixel(q, r) {
            const size = 25;
            const x = size * (Math.sqrt(3) * q + Math.sqrt(3)/2 * r) + 250;
            const y = size * (3/2 * r) + 250;
            return { x: x - 25, y: y - 29 };
        }

        // Get color class for hex cell (3-color pattern)
        function getCellColor(q, r) {
            const s = -q - r;
            const mod = ((q % 3) + 3) % 3;
            return `color-${mod}`;
        }

        function renderBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';

            const cells = JSON.parse(wasm_get_all_cells());
            const boardState = JSON.parse(game.get_board());
            
            cells.forEach(([q, r]) => {
                const hex = document.createElement('div');
                hex.className = `hex ${getCellColor(q, r)}`;
                
                const pos = hexToPixel(q, r);
                hex.style.left = `${pos.x}px`;
                hex.style.top = `${pos.y}px`;
                
                const key = `${q},${r}`;
                const piece = boardState[key];
                
                if (piece) {
                    const pieceEl = document.createElement('span');
                    pieceEl.className = `piece ${piece.color.toLowerCase()}`;
                    const colorKey = piece.color === 'White' ? 'white' : 'black';
                    pieceEl.textContent = PIECE_SYMBOLS[piece.piece_type]?.[colorKey] || '?';
                    hex.appendChild(pieceEl);
                }
                
                // Highlight selected cell
                if (selectedCell && selectedCell.q === q && selectedCell.r === r) {
                    hex.classList.add('selected');
                }
                
                // Highlight legal moves
                const isLegalMove = legalMoves.some(m => m.to.q === q && m.to.r === r);
                if (isLegalMove) {
                    const move = legalMoves.find(m => m.to.q === q && m.to.r === r);
                    hex.classList.add(move.captured ? 'legal-capture' : 'legal-move');
                }
                
                hex.onclick = () => handleClick(q, r);
                boardEl.appendChild(hex);
            });
        }

        function handleClick(q, r) {
            const key = `${q},${r}`;
            const boardState = JSON.parse(game.get_board());
            const piece = boardState[key];
            const currentTurn = game.get_turn();
            
            // If clicking on a legal move destination
            if (selectedCell && legalMoves.some(m => m.to.q === q && m.to.r === r)) {
                const success = game.make_move(selectedCell.q, selectedCell.r, q, r);
                if (success) {
                    selectedCell = null;
                    legalMoves = [];
                    updateUI();
                    updateEvaluation();
                    return;
                }
            }
            
            // If clicking on own piece, select it
            if (piece && piece.color.toLowerCase() === currentTurn) {
                selectedCell = { q, r };
                legalMoves = JSON.parse(game.get_legal_moves_for_piece(q, r));
            } else {
                selectedCell = null;
                legalMoves = [];
            }
            
            renderBoard();
        }

        function updateUI() {
            renderBoard();
            
            const turn = game.get_turn();
            const status = JSON.parse(game.get_status());
            const moveNum = game.get_move_number();
            const isCheck = game.is_in_check();
            
            document.getElementById('turn').textContent = turn;
            document.getElementById('move-num').textContent = moveNum;
            
            const statusEl = document.getElementById('status');
            if (status === 'Ongoing') {
                statusEl.textContent = isCheck ? `${turn.toUpperCase()} is in CHECK!` : 'Game in progress';
                statusEl.className = isCheck ? 'status check' : 'status';
            } else if (status.Checkmate) {
                statusEl.textContent = `CHECKMATE! ${status.Checkmate.winner} wins!`;
                statusEl.className = 'status';
            } else if (status === 'Stalemate') {
                statusEl.textContent = 'STALEMATE! Draw.';
                statusEl.className = 'status';
            } else if (status.Resigned) {
                statusEl.textContent = `${status.Resigned.winner} wins by resignation!`;
                statusEl.className = 'status';
            }
            
            // Update move history
            const history = JSON.parse(game.get_history());
            const historyEl = document.getElementById('moves-list');
            historyEl.innerHTML = history.map((m, i) => {
                const num = Math.floor(i/2) + 1;
                const prefix = i % 2 === 0 ? `${num}. ` : '';
                return `${prefix}${m.from.q},${m.from.r} → ${m.to.q},${m.to.r}`;
            }).join('<br>');
        }

        window.newGame = function() {
            stopAutoPlay();
            game = new WasmGame();
            game.clear_ai_cache();
            selectedCell = null;
            legalMoves = [];
            updateUI();
            updateEvaluation();
        };

        window.resign = function() {
            stopAutoPlay();
            game.resign();
            updateUI();
        };

        window.makeAIMove = async function() {
            const status = JSON.parse(game.get_status());
            if (status !== 'Ongoing') return;
            
            const difficulty = document.getElementById('ai-difficulty').value;
            const aiStatus = document.getElementById('ai-status');
            const aiBtn = document.getElementById('ai-move-btn');
            
            aiBtn.disabled = true;
            aiStatus.textContent = 'AI thinking...';
            aiStatus.className = 'thinking';
            
            // Use setTimeout to allow UI to update
            await new Promise(r => setTimeout(r, 10));
            
            const success = game.make_ai_move(difficulty);
            
            if (success) {
                selectedCell = null;
                legalMoves = [];
                updateUI();
                updateEvaluation();
                aiStatus.textContent = '';
            } else {
                aiStatus.textContent = 'No legal moves available';
            }
            
            aiStatus.className = '';
            aiBtn.disabled = false;
        };

        window.getAIHint = async function() {
            const status = JSON.parse(game.get_status());
            if (status !== 'Ongoing') return;
            
            const difficulty = document.getElementById('ai-difficulty').value;
            const aiStatus = document.getElementById('ai-status');
            const hintBtn = document.getElementById('ai-hint-btn');
            
            hintBtn.disabled = true;
            aiStatus.textContent = 'Calculating hint...';
            aiStatus.className = 'thinking';
            
            await new Promise(r => setTimeout(r, 10));
            
            const result = game.get_ai_move(difficulty);
            
            if (result && result !== 'null') {
                const move = JSON.parse(result);
                const fromQ = move.from[0], fromR = move.from[1];
                const toQ = move.to[0], toR = move.to[1];
                const scoreStr = (move.score / 100).toFixed(2);
                aiStatus.textContent = `Best: (${fromQ},${fromR}) → (${toQ},${toR}), Score: ${scoreStr}, Nodes: ${move.nodes}`;
                
                // Highlight the suggested move
                selectedCell = { q: fromQ, r: fromR };
                legalMoves = JSON.parse(game.get_legal_moves_for_piece(fromQ, fromR));
                renderBoard();
            } else {
                aiStatus.textContent = 'No moves available';
            }
            
            aiStatus.className = '';
            hintBtn.disabled = false;
        };

        window.toggleAutoPlay = function() {
            if (autoPlayInterval) {
                stopAutoPlay();
            } else {
                startAutoPlay();
            }
        };

        function startAutoPlay() {
            const status = JSON.parse(game.get_status());
            if (status !== 'Ongoing') return;
            
            document.getElementById('ai-status').textContent = 'Auto-play enabled';
            autoPlayInterval = setInterval(async () => {
                const status = JSON.parse(game.get_status());
                if (status !== 'Ongoing') {
                    stopAutoPlay();
                    return;
                }
                await makeAIMove();
            }, 500);
        }

        function stopAutoPlay() {
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
                autoPlayInterval = null;
                document.getElementById('ai-status').textContent = 'Auto-play stopped';
            }
        }

        function updateEvaluation() {
            const evalScore = game.evaluate();
            const evalText = document.getElementById('eval-text');
            const evalFill = document.getElementById('eval-fill');
            
            // Convert centipawns to display value
            const displayScore = (evalScore / 100).toFixed(2);
            const prefix = evalScore > 0 ? '+' : '';
            evalText.textContent = `${prefix}${displayScore}`;
            
            // Calculate fill width (0-100%), center is 50%
            // Clamp to ±10 pawns range for display
            const clampedScore = Math.max(-1000, Math.min(1000, evalScore));
            const fillPercent = 50 + (clampedScore / 20); // ±1000 maps to ±50%
            evalFill.style.width = `${fillPercent}%`;
            
            // Color based on advantage
            if (evalScore > 50) {
                evalFill.style.background = '#00d9ff'; // White advantage - cyan
            } else if (evalScore < -50) {
                evalFill.style.background = '#ff6b6b'; // Black advantage - red
            } else {
                evalFill.style.background = '#888'; // Equal - gray
            }
        }

        // Initialize
        async function main() {
            await init();
            game = new WasmGame();
            updateUI();
            updateEvaluation();
            document.getElementById('status').textContent = 'Game ready - White to move';
        }

        main().catch(console.error);
    </script>
</body>
</html>
