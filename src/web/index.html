<!DOCTYPE html>
<!--
  Underchex - Hexagonal Chess Variant
  Standalone HTML + JS implementation (no dependencies)
  
  Signed-by: agent #2 claude-sonnet-4 via opencode 20260122T02:28:36
-->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Underchex - Hexagonal Chess</title>
  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: #eee;
      margin: 0;
      padding: 20px;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    h1 {
      margin: 0 0 10px 0;
      font-size: 2em;
      color: #e94560;
    }
    
    .game-container {
      display: flex;
      gap: 30px;
      flex-wrap: wrap;
      justify-content: center;
      align-items: flex-start;
    }
    
    .board-container {
      position: relative;
    }
    
    canvas {
      border-radius: 10px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    }
    
    .info-panel {
      background: #16213e;
      padding: 20px;
      border-radius: 10px;
      min-width: 250px;
      max-width: 300px;
    }
    
    .info-panel h2 {
      margin: 0 0 15px 0;
      color: #e94560;
      font-size: 1.2em;
    }
    
    .turn-indicator {
      font-size: 1.3em;
      margin-bottom: 15px;
      padding: 10px;
      border-radius: 5px;
      text-align: center;
    }
    
    .turn-indicator.white {
      background: #f0f0f0;
      color: #333;
    }
    
    .turn-indicator.black {
      background: #333;
      color: #f0f0f0;
    }
    
    .status {
      padding: 10px;
      border-radius: 5px;
      margin-bottom: 15px;
      text-align: center;
    }
    
    .status.check {
      background: #ff6b6b;
      color: #fff;
    }
    
    .status.checkmate {
      background: #e94560;
      color: #fff;
      font-weight: bold;
    }
    
    .status.stalemate {
      background: #ffd93d;
      color: #333;
    }
    
    .move-history {
      max-height: 300px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 0.9em;
      background: #0f0f23;
      padding: 10px;
      border-radius: 5px;
      margin-bottom: 15px;
    }
    
    .move-history div {
      padding: 2px 0;
    }
    
    .move-history .white-move {
      color: #fff;
    }
    
    .move-history .black-move {
      color: #aaa;
    }
    
    button {
      background: #e94560;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1em;
      width: 100%;
      margin-bottom: 10px;
      transition: background 0.2s;
    }
    
    button:hover {
      background: #ff6b8a;
    }
    
    .legend {
      margin-top: 15px;
      font-size: 0.85em;
    }
    
    .legend h3 {
      margin: 0 0 10px 0;
      color: #e94560;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 5px;
    }
    
    .legend-symbol {
      font-size: 1.5em;
      width: 30px;
      text-align: center;
    }
    
    .coords-display {
      font-family: monospace;
      font-size: 0.8em;
      color: #888;
      margin-top: 10px;
    }
    
    /* Promotion dialog */
    .promotion-dialog {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    
    .promotion-dialog.active {
      display: flex;
    }
    
    .promotion-content {
      background: #16213e;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
    }
    
    .promotion-content h3 {
      color: #e94560;
      margin: 0 0 15px 0;
    }
    
    .promotion-options {
      display: flex;
      gap: 10px;
      justify-content: center;
    }
    
    .promotion-option {
      width: 60px;
      height: 60px;
      border-radius: 10px;
      border: 2px solid #444;
      background: #0f0f23;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.8em;
      font-weight: bold;
      transition: all 0.2s;
    }
    
    .promotion-option:hover {
      border-color: #e94560;
      background: #1a1a2e;
    }
    
    .promotion-option.white {
      background: #f0f0f0;
      color: #333;
    }
    
    .promotion-option.black {
      background: #333;
      color: #f0f0f0;
    }
  </style>
</head>
<body>
  <h1>Underchex</h1>
  <p style="color: #888; margin-bottom: 20px;">Hexagonal Chess Variant</p>
  
  <div class="game-container">
    <div class="board-container">
      <canvas id="board" width="600" height="600"></canvas>
    </div>
    
    <div class="info-panel">
      <h2>Game Info</h2>
      <div id="turn-indicator" class="turn-indicator white">White's Turn</div>
      <div id="status" class="status" style="display: none;"></div>
      
      <h2>Move History</h2>
      <div id="move-history" class="move-history"></div>
      
      <button id="new-game-btn">New Game (2 Player)</button>
      <button id="ai-game-btn">Play vs AI</button>
      <button id="undo-btn">Undo Move</button>
      
      <div id="ai-controls" style="display: none; margin-top: 10px;">
        <label style="display: block; margin-bottom: 5px; color: #888;">AI Difficulty:</label>
        <select id="ai-difficulty" style="width: 100%; padding: 8px; border-radius: 5px; background: #0f0f23; color: #eee; border: 1px solid #444;">
          <option value="easy">Easy (Depth 2)</option>
          <option value="medium" selected>Medium (Depth 4)</option>
          <option value="hard">Hard (Depth 6)</option>
        </select>
        <div id="ai-thinking" style="display: none; margin-top: 10px; color: #e94560; text-align: center;">
          AI is thinking...
        </div>
      </div>
      
      <div class="legend">
        <h3>Pieces</h3>
        <div class="legend-item"><span class="legend-symbol">K</span> King</div>
        <div class="legend-item"><span class="legend-symbol">Q</span> Queen</div>
        <div class="legend-item"><span class="legend-symbol">C</span> Chariot</div>
        <div class="legend-item"><span class="legend-symbol">L</span> Lance</div>
        <div class="legend-item"><span class="legend-symbol">N</span> Knight</div>
        <div class="legend-item"><span class="legend-symbol">P</span> Pawn</div>
      </div>
      
      <div id="coords-display" class="coords-display"></div>
    </div>
  </div>
  
  <!-- Promotion Dialog -->
  <div id="promotion-dialog" class="promotion-dialog">
    <div class="promotion-content">
      <h3>Choose Promotion</h3>
      <div class="promotion-options">
        <div class="promotion-option" data-piece="queen">Q</div>
        <div class="promotion-option" data-piece="chariot">C</div>
        <div class="promotion-option" data-piece="lance">L</div>
        <div class="promotion-option" data-piece="knight">N</div>
      </div>
    </div>
  </div>

  <script>
    // =========================================================================
    // UNDERCHEX GAME ENGINE (Standalone JS Implementation)
    // Signed-by: agent #2 claude-sonnet-4 via opencode 20260122T02:28:36
    // =========================================================================
    
    const BOARD_RADIUS = 4;
    
    const DIRECTIONS = {
      N:  { q:  0, r: -1 },
      S:  { q:  0, r:  1 },
      NE: { q:  1, r: -1 },
      SW: { q: -1, r:  1 },
      NW: { q: -1, r:  0 },
      SE: { q:  1, r:  0 },
    };
    
    const ALL_DIRECTIONS = ['N', 'S', 'NE', 'SW', 'NW', 'SE'];
    const DIAGONAL_DIRECTIONS = ['NE', 'NW', 'SE', 'SW'];
    const LANCE_A_DIRECTIONS = ['N', 'S', 'NW', 'SE'];
    const LANCE_B_DIRECTIONS = ['N', 'S', 'NE', 'SW'];
    
    const KNIGHT_OFFSETS = [
      { q:  1, r: -2 },
      { q: -1, r: -1 },
      { q:  2, r: -1 },
      { q:  1, r:  1 },
      { q: -1, r:  2 },
      { q: -2, r:  1 },
    ];
    
    // Utility functions
    function coordToString(coord) {
      return `${coord.q},${coord.r}`;
    }
    
    function stringToCoord(str) {
      const [q, r] = str.split(',').map(Number);
      return { q, r };
    }
    
    function coordsEqual(a, b) {
      return a.q === b.q && a.r === b.r;
    }
    
    function isValidCell(coord) {
      const { q, r } = coord;
      const s = -q - r;
      return Math.max(Math.abs(q), Math.abs(r), Math.abs(s)) <= BOARD_RADIUS;
    }
    
    function getAllCells() {
      const cells = [];
      for (let q = -BOARD_RADIUS; q <= BOARD_RADIUS; q++) {
        for (let r = -BOARD_RADIUS; r <= BOARD_RADIUS; r++) {
          const coord = { q, r };
          if (isValidCell(coord)) cells.push(coord);
        }
      }
      return cells;
    }
    
    function getNeighbor(coord, direction) {
      const delta = DIRECTIONS[direction];
      const neighbor = { q: coord.q + delta.q, r: coord.r + delta.r };
      return isValidCell(neighbor) ? neighbor : null;
    }
    
    function getRay(start, direction) {
      const cells = [];
      let current = start;
      while (true) {
        const delta = DIRECTIONS[direction];
        const next = { q: current.q + delta.q, r: current.r + delta.r };
        if (!isValidCell(next)) break;
        cells.push(next);
        current = next;
      }
      return cells;
    }
    
    function getKnightTargets(from) {
      const targets = [];
      for (const offset of KNIGHT_OFFSETS) {
        const target = { q: from.q + offset.q, r: from.r + offset.r };
        if (isValidCell(target)) targets.push(target);
      }
      return targets;
    }
    
    function getOppositeDirection(dir) {
      const opposites = { N: 'S', S: 'N', NE: 'SW', SW: 'NE', NW: 'SE', SE: 'NW' };
      return opposites[dir];
    }
    
    // Board operations
    function getPieceAt(board, coord) {
      return board.get(coordToString(coord));
    }
    
    function isOccupied(board, coord) {
      return board.has(coordToString(coord));
    }
    
    function hasEnemy(board, coord, color) {
      const piece = getPieceAt(board, coord);
      return piece && piece.color !== color;
    }
    
    function hasFriendly(board, coord, color) {
      const piece = getPieceAt(board, coord);
      return piece && piece.color === color;
    }
    
    function getForwardDirection(color) {
      return color === 'white' ? 'N' : 'S';
    }
    
    function getPawnCaptureDirections(color) {
      return color === 'white' ? ['N', 'NE', 'NW'] : ['S', 'SE', 'SW'];
    }
    
    function getPieceDirections(piece) {
      switch (piece.type) {
        case 'king':
        case 'queen':
          return ALL_DIRECTIONS;
        case 'chariot':
          return DIAGONAL_DIRECTIONS;
        case 'lance':
          return piece.variant === 'A' ? LANCE_A_DIRECTIONS : LANCE_B_DIRECTIONS;
        default:
          return [];
      }
    }
    
    function isSlider(pieceType) {
      return pieceType === 'queen' || pieceType === 'lance' || pieceType === 'chariot';
    }
    
    // Pawn promotion
    const PROMOTION_TARGETS = ['queen', 'chariot', 'lance', 'knight'];
    
    function isPromotionZone(coord, color) {
      const targetR = color === 'white' ? -BOARD_RADIUS : BOARD_RADIUS;
      return coord.r === targetR;
    }
    
    // Move generation
    function generatePseudoLegalMoves(board, piece, from) {
      const moves = [];
      
      if (piece.type === 'pawn') {
        const forwardDir = getForwardDirection(piece.color);
        const forward = getNeighbor(from, forwardDir);
        if (forward && !isOccupied(board, forward)) {
          if (isPromotionZone(forward, piece.color)) {
            for (const promotionType of PROMOTION_TARGETS) {
              moves.push({ piece, from, to: forward, promotion: promotionType });
            }
          } else {
            moves.push({ piece, from, to: forward });
          }
        }
        for (const dir of getPawnCaptureDirections(piece.color)) {
          const target = getNeighbor(from, dir);
          if (target && hasEnemy(board, target, piece.color)) {
            const captured = getPieceAt(board, target);
            if (isPromotionZone(target, piece.color)) {
              for (const promotionType of PROMOTION_TARGETS) {
                moves.push({ piece, from, to: target, captured, promotion: promotionType });
              }
            } else {
              moves.push({ piece, from, to: target, captured });
            }
          }
        }
      } else if (piece.type === 'king') {
        for (const dir of ALL_DIRECTIONS) {
          const target = getNeighbor(from, dir);
          if (target && !hasFriendly(board, target, piece.color)) {
            moves.push({ piece, from, to: target, captured: getPieceAt(board, target) });
          }
        }
      } else if (piece.type === 'knight') {
        for (const target of getKnightTargets(from)) {
          if (!hasFriendly(board, target, piece.color)) {
            moves.push({ piece, from, to: target, captured: getPieceAt(board, target) });
          }
        }
      } else {
        // Slider pieces (queen, lance, chariot)
        for (const dir of getPieceDirections(piece)) {
          for (const target of getRay(from, dir)) {
            if (hasFriendly(board, target, piece.color)) break;
            moves.push({ piece, from, to: target, captured: getPieceAt(board, target) });
            if (getPieceAt(board, target)) break;
          }
        }
      }
      
      return moves;
    }
    
    function findKing(board, color) {
      for (const [posStr, piece] of board.entries()) {
        if (piece.type === 'king' && piece.color === color) {
          return stringToCoord(posStr);
        }
      }
      return null;
    }
    
    function isAttacked(board, target, byColor) {
      // Pawn attacks
      for (const dir of getPawnCaptureDirections(byColor)) {
        const reverseDir = getOppositeDirection(dir);
        const attacker = getNeighbor(target, reverseDir);
        if (attacker) {
          const piece = getPieceAt(board, attacker);
          if (piece?.type === 'pawn' && piece.color === byColor) return true;
        }
      }
      
      // King attacks
      for (const dir of ALL_DIRECTIONS) {
        const attacker = getNeighbor(target, dir);
        if (attacker) {
          const piece = getPieceAt(board, attacker);
          if (piece?.type === 'king' && piece.color === byColor) return true;
        }
      }
      
      // Knight attacks
      for (const attackerPos of getKnightTargets(target)) {
        const piece = getPieceAt(board, attackerPos);
        if (piece?.type === 'knight' && piece.color === byColor) return true;
      }
      
      // Slider attacks
      for (const dir of ALL_DIRECTIONS) {
        for (const pos of getRay(target, dir)) {
          const piece = getPieceAt(board, pos);
          if (!piece) continue;
          if (piece.color !== byColor) break;
          const pieceDirections = getPieceDirections(piece);
          const reverseDir = getOppositeDirection(dir);
          if (pieceDirections.includes(reverseDir) && isSlider(piece.type)) return true;
          break;
        }
      }
      
      return false;
    }
    
    function isInCheck(board, color) {
      const kingPos = findKing(board, color);
      if (!kingPos) return false;
      return isAttacked(board, kingPos, color === 'white' ? 'black' : 'white');
    }
    
    function applyMove(board, move) {
      const newBoard = new Map(board);
      newBoard.delete(coordToString(move.from));
      
      // Handle promotion
      if (move.promotion) {
        const promotedPiece = {
          type: move.promotion,
          color: move.piece.color,
          ...(move.promotion === 'lance' ? { variant: 'A' } : {}),
        };
        newBoard.set(coordToString(move.to), promotedPiece);
      } else {
        newBoard.set(coordToString(move.to), move.piece);
      }
      
      return newBoard;
    }
    
    function generateLegalMoves(board, piece, from) {
      return generatePseudoLegalMoves(board, piece, from).filter(move => {
        const newBoard = applyMove(board, move);
        return !isInCheck(newBoard, piece.color);
      });
    }
    
    function generateAllLegalMoves(board, color) {
      const moves = [];
      for (const [posStr, piece] of board.entries()) {
        if (piece.color !== color) continue;
        const from = stringToCoord(posStr);
        moves.push(...generateLegalMoves(board, piece, from));
      }
      return moves;
    }
    
    // Game state
    function getStartingPosition() {
      const pieces = [];
      
      // White pieces
      pieces.push({ piece: { type: 'king', color: 'white' }, position: { q: 0, r: 4 } });
      pieces.push({ piece: { type: 'queen', color: 'white' }, position: { q: 1, r: 3 } });
      pieces.push({ piece: { type: 'chariot', color: 'white' }, position: { q: -2, r: 4 } });
      pieces.push({ piece: { type: 'chariot', color: 'white' }, position: { q: 2, r: 3 } });
      pieces.push({ piece: { type: 'lance', color: 'white', variant: 'A' }, position: { q: -1, r: 4 } });
      pieces.push({ piece: { type: 'lance', color: 'white', variant: 'B' }, position: { q: 1, r: 4 } });
      pieces.push({ piece: { type: 'knight', color: 'white' }, position: { q: -2, r: 3 } });
      pieces.push({ piece: { type: 'knight', color: 'white' }, position: { q: 2, r: 4 } });
      
      // White pawns
      for (const pos of [{ q: -3, r: 3 }, { q: -2, r: 2 }, { q: -1, r: 2 }, { q: 0, r: 2 }, { q: 1, r: 2 }, { q: 2, r: 2 }]) {
        pieces.push({ piece: { type: 'pawn', color: 'white' }, position: pos });
      }
      
      // Black pieces
      pieces.push({ piece: { type: 'king', color: 'black' }, position: { q: 0, r: -4 } });
      pieces.push({ piece: { type: 'queen', color: 'black' }, position: { q: -1, r: -3 } });
      pieces.push({ piece: { type: 'chariot', color: 'black' }, position: { q: 2, r: -4 } });
      pieces.push({ piece: { type: 'chariot', color: 'black' }, position: { q: -2, r: -3 } });
      pieces.push({ piece: { type: 'lance', color: 'black', variant: 'A' }, position: { q: 1, r: -4 } });
      pieces.push({ piece: { type: 'lance', color: 'black', variant: 'B' }, position: { q: -1, r: -4 } });
      pieces.push({ piece: { type: 'knight', color: 'black' }, position: { q: 2, r: -3 } });
      pieces.push({ piece: { type: 'knight', color: 'black' }, position: { q: -2, r: -4 } });
      
      // Black pawns
      for (const pos of [{ q: 3, r: -3 }, { q: 2, r: -2 }, { q: 1, r: -2 }, { q: 0, r: -2 }, { q: -1, r: -2 }, { q: -2, r: -2 }]) {
        pieces.push({ piece: { type: 'pawn', color: 'black' }, position: pos });
      }
      
      return pieces;
    }
    
    function createNewGame() {
      const board = new Map();
      for (const { piece, position } of getStartingPosition()) {
        board.set(coordToString(position), piece);
      }
      return {
        board,
        turn: 'white',
        moveNumber: 1,
        history: [],
        status: { type: 'ongoing' }
      };
    }
    
    function makeMove(state, from, to, promotionChoice = null) {
      if (state.status.type !== 'ongoing') return null;
      
      const piece = getPieceAt(state.board, from);
      if (!piece || piece.color !== state.turn) return null;
      
      const legalMoves = generateLegalMoves(state.board, piece, from);
      
      // Filter moves to the target cell
      let movesToTarget = legalMoves.filter(m => coordsEqual(m.to, to));
      if (movesToTarget.length === 0) return null;
      
      // Handle promotion selection
      let move;
      if (movesToTarget[0].promotion) {
        // This is a promotion move
        if (promotionChoice) {
          move = movesToTarget.find(m => m.promotion === promotionChoice);
        } else {
          // Default to queen for now (UI will handle actual choice)
          move = movesToTarget.find(m => m.promotion === 'queen');
        }
      } else {
        move = movesToTarget[0];
      }
      
      if (!move) return null;
      
      const newBoard = applyMove(state.board, move);
      const nextTurn = state.turn === 'white' ? 'black' : 'white';
      
      // Determine game status
      const opponentMoves = generateAllLegalMoves(newBoard, nextTurn);
      let status;
      if (opponentMoves.length === 0) {
        if (isInCheck(newBoard, nextTurn)) {
          status = { type: 'checkmate', winner: state.turn };
        } else {
          status = { type: 'stalemate' };
        }
      } else {
        status = { type: 'ongoing' };
      }
      
      return {
        board: newBoard,
        turn: nextTurn,
        moveNumber: state.turn === 'black' ? state.moveNumber + 1 : state.moveNumber,
        history: [...state.history, { move, previousBoard: state.board }],
        status
      };
    }
    
    // Check if a move would be a promotion
    function isPromotionMove(state, from, to) {
      const piece = getPieceAt(state.board, from);
      if (!piece || piece.type !== 'pawn') return false;
      const legalMoves = generateLegalMoves(state.board, piece, from);
      const movesToTarget = legalMoves.filter(m => coordsEqual(m.to, to));
      return movesToTarget.length > 0 && movesToTarget[0].promotion;
    }
    
    // =========================================================================
    // AI ENGINE
    // Signed-by: agent #3 claude-sonnet-4 via opencode 20260122T02:35:07
    // =========================================================================
    
    const PIECE_VALUES = {
      pawn: 100,
      knight: 300,
      lance: 450,
      chariot: 450,
      queen: 900,
      king: 0
    };
    
    const CHECKMATE_VALUE = 100000;
    
    function hexDistance(a, b) {
      const dq = Math.abs(a.q - b.q);
      const dr = Math.abs(a.r - b.r);
      const ds = Math.abs((-a.q - a.r) - (-b.q - b.r));
      return Math.max(dq, dr, ds);
    }
    
    function getCentralityBonus(coord) {
      const distanceFromCenter = hexDistance(coord, { q: 0, r: 0 });
      return (BOARD_RADIUS - distanceFromCenter) * 5;
    }
    
    function getPawnAdvancementBonus(coord, color) {
      const targetR = color === 'white' ? -BOARD_RADIUS : BOARD_RADIUS;
      const startR = color === 'white' ? BOARD_RADIUS : -BOARD_RADIUS;
      const totalDistance = Math.abs(targetR - startR);
      const distanceFromStart = Math.abs(coord.r - startR);
      const progress = distanceFromStart / totalDistance;
      return Math.floor(progress * progress * 50);
    }
    
    function getPiecePositionBonus(piece, coord) {
      let bonus = getCentralityBonus(coord);
      if (piece.type === 'pawn') {
        bonus += getPawnAdvancementBonus(coord, piece.color);
      }
      if (piece.type === 'king') {
        const distFromCenter = hexDistance(coord, { q: 0, r: 0 });
        if (distFromCenter < 2) bonus -= 30;
      }
      return bonus;
    }
    
    function evaluateMaterial(board) {
      let score = 0;
      for (const [posStr, piece] of board.entries()) {
        const value = PIECE_VALUES[piece.type];
        const coord = stringToCoord(posStr);
        const positionBonus = getPiecePositionBonus(piece, coord);
        const totalValue = value + positionBonus;
        score += piece.color === 'white' ? totalValue : -totalValue;
      }
      return score;
    }
    
    function evaluateMobility(board, color) {
      const moves = generateAllLegalMoves(board, color);
      return moves.length * 2;
    }
    
    function evaluatePosition(board) {
      let score = evaluateMaterial(board);
      score += evaluateMobility(board, 'white') - evaluateMobility(board, 'black');
      if (isInCheck(board, 'white')) score -= 50;
      if (isInCheck(board, 'black')) score += 50;
      return score;
    }
    
    function estimateMoveValue(move) {
      let score = 0;
      if (move.captured) {
        score += PIECE_VALUES[move.captured.type] * 10 - PIECE_VALUES[move.piece.type];
      }
      if (move.promotion) {
        score += PIECE_VALUES[move.promotion] - PIECE_VALUES.pawn;
      }
      score += getCentralityBonus(move.to);
      return score;
    }
    
    function orderMoves(moves) {
      return [...moves].sort((a, b) => estimateMoveValue(b) - estimateMoveValue(a));
    }
    
    function alphaBeta(board, depth, alpha, beta, maximizing, stats) {
      stats.nodesSearched++;
      
      const color = maximizing ? 'white' : 'black';
      const moves = generateAllLegalMoves(board, color);
      
      if (moves.length === 0) {
        if (isInCheck(board, color)) {
          return maximizing ? -CHECKMATE_VALUE + stats.nodesSearched : CHECKMATE_VALUE - stats.nodesSearched;
        }
        return 0; // Stalemate
      }
      
      if (depth === 0) {
        return evaluatePosition(board);
      }
      
      const orderedMoves = orderMoves(moves);
      
      if (maximizing) {
        let maxEval = -Infinity;
        for (const move of orderedMoves) {
          const newBoard = applyMove(board, move);
          const evalScore = alphaBeta(newBoard, depth - 1, alpha, beta, false, stats);
          maxEval = Math.max(maxEval, evalScore);
          alpha = Math.max(alpha, evalScore);
          if (beta <= alpha) {
            stats.cutoffs++;
            break;
          }
        }
        return maxEval;
      } else {
        let minEval = Infinity;
        for (const move of orderedMoves) {
          const newBoard = applyMove(board, move);
          const evalScore = alphaBeta(newBoard, depth - 1, alpha, beta, true, stats);
          minEval = Math.min(minEval, evalScore);
          beta = Math.min(beta, evalScore);
          if (beta <= alpha) {
            stats.cutoffs++;
            break;
          }
        }
        return minEval;
      }
    }
    
    function findBestMove(board, color, depth) {
      const stats = { nodesSearched: 0, cutoffs: 0 };
      const moves = generateAllLegalMoves(board, color);
      
      if (moves.length === 0) {
        return { move: null, score: 0, stats };
      }
      
      const maximizing = color === 'white';
      const orderedMoves = orderMoves(moves);
      
      let bestMove = orderedMoves[0];
      let bestScore = maximizing ? -Infinity : Infinity;
      let alpha = -Infinity;
      let beta = Infinity;
      
      for (const move of orderedMoves) {
        const newBoard = applyMove(board, move);
        const evalScore = alphaBeta(newBoard, depth - 1, alpha, beta, !maximizing, stats);
        
        if (maximizing) {
          if (evalScore > bestScore) {
            bestScore = evalScore;
            bestMove = move;
          }
          alpha = Math.max(alpha, evalScore);
        } else {
          if (evalScore < bestScore) {
            bestScore = evalScore;
            bestMove = move;
          }
          beta = Math.min(beta, evalScore);
        }
      }
      
      return { move: bestMove, score: bestScore, stats };
    }
    
    function getDifficultyDepth(difficulty) {
      switch (difficulty) {
        case 'easy': return 2;
        case 'medium': return 4;
        case 'hard': return 6;
        default: return 4;
      }
    }
    
    // =========================================================================
    // UI RENDERING
    // =========================================================================
    
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    
    const HEX_SIZE = 32;
    const CENTER_X = canvas.width / 2;
    const CENTER_Y = canvas.height / 2;
    
    let gameState = createNewGame();
    let selectedCell = null;
    let legalMovesForSelected = [];
    let hoveredCell = null;
    let aiEnabled = false;
    let aiColor = 'black'; // AI always plays black when enabled
    let aiThinking = false;
    
    // Convert axial to pixel coordinates
    function axialToPixel(q, r) {
      const x = HEX_SIZE * (Math.sqrt(3) * q + Math.sqrt(3) / 2 * r) + CENTER_X;
      const y = HEX_SIZE * (3 / 2 * r) + CENTER_Y;
      return { x, y };
    }
    
    // Convert pixel to axial coordinates
    function pixelToAxial(px, py) {
      const x = px - CENTER_X;
      const y = py - CENTER_Y;
      const q = (Math.sqrt(3) / 3 * x - 1 / 3 * y) / HEX_SIZE;
      const r = (2 / 3 * y) / HEX_SIZE;
      return hexRound(q, r);
    }
    
    function hexRound(q, r) {
      const s = -q - r;
      let rq = Math.round(q);
      let rr = Math.round(r);
      let rs = Math.round(s);
      
      const qDiff = Math.abs(rq - q);
      const rDiff = Math.abs(rr - r);
      const sDiff = Math.abs(rs - s);
      
      if (qDiff > rDiff && qDiff > sDiff) {
        rq = -rr - rs;
      } else if (rDiff > sDiff) {
        rr = -rq - rs;
      }
      
      return { q: rq, r: rr };
    }
    
    // Draw a hexagon
    function drawHex(x, y, size, fill, stroke) {
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = Math.PI / 180 * (60 * i - 30);
        const hx = x + size * Math.cos(angle);
        const hy = y + size * Math.sin(angle);
        if (i === 0) ctx.moveTo(hx, hy);
        else ctx.lineTo(hx, hy);
      }
      ctx.closePath();
      if (fill) {
        ctx.fillStyle = fill;
        ctx.fill();
      }
      if (stroke) {
        ctx.strokeStyle = stroke;
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }
    
    // Get cell color based on coordinate (3-color scheme for hex grids)
    function getCellColor(q, r) {
      const mod = ((q - r) % 3 + 3) % 3;
      const colors = ['#2d5016', '#3d6b22', '#4d7b2e'];
      return colors[mod];
    }
    
    // Get piece symbol
    function getPieceSymbol(piece) {
      const symbols = {
        king: 'K',
        queen: 'Q',
        chariot: 'C',
        lance: 'L',
        knight: 'N',
        pawn: 'P'
      };
      return symbols[piece.type] || '?';
    }
    
    // Draw the entire board
    function drawBoard() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      const cells = getAllCells();
      
      // Draw cells
      for (const cell of cells) {
        const { x, y } = axialToPixel(cell.q, cell.r);
        let fillColor = getCellColor(cell.q, cell.r);
        
        // Highlight selected cell
        if (selectedCell && coordsEqual(cell, selectedCell)) {
          fillColor = '#ffcc00';
        }
        // Highlight legal move destinations
        else if (legalMovesForSelected.some(m => coordsEqual(m.to, cell))) {
          const isCapture = getPieceAt(gameState.board, cell);
          fillColor = isCapture ? '#ff6b6b' : '#6bff6b';
        }
        // Highlight hovered cell
        else if (hoveredCell && coordsEqual(cell, hoveredCell)) {
          fillColor = '#5a8a3a';
        }
        
        drawHex(x, y, HEX_SIZE, fillColor, '#1a1a2e');
        
        // Draw coordinate for debugging (optional - can be toggled)
        // ctx.fillStyle = '#ffffff44';
        // ctx.font = '8px sans-serif';
        // ctx.textAlign = 'center';
        // ctx.fillText(`${cell.q},${cell.r}`, x, y + 15);
      }
      
      // Draw pieces
      for (const cell of cells) {
        const piece = getPieceAt(gameState.board, cell);
        if (piece) {
          const { x, y } = axialToPixel(cell.q, cell.r);
          
          // Draw piece background
          ctx.beginPath();
          ctx.arc(x, y, HEX_SIZE * 0.6, 0, Math.PI * 2);
          ctx.fillStyle = piece.color === 'white' ? '#f0f0f0' : '#333';
          ctx.fill();
          ctx.strokeStyle = piece.color === 'white' ? '#ccc' : '#555';
          ctx.lineWidth = 2;
          ctx.stroke();
          
          // Draw piece symbol
          ctx.fillStyle = piece.color === 'white' ? '#333' : '#f0f0f0';
          ctx.font = `bold ${HEX_SIZE * 0.8}px sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(getPieceSymbol(piece), x, y);
        }
      }
      
      // Draw check indicator on king
      if (isInCheck(gameState.board, gameState.turn)) {
        const kingPos = findKing(gameState.board, gameState.turn);
        if (kingPos) {
          const { x, y } = axialToPixel(kingPos.q, kingPos.r);
          ctx.beginPath();
          ctx.arc(x, y, HEX_SIZE * 0.8, 0, Math.PI * 2);
          ctx.strokeStyle = '#ff0000';
          ctx.lineWidth = 3;
          ctx.stroke();
        }
      }
    }
    
    // Make AI move
    function makeAIMove() {
      if (!aiEnabled || gameState.turn !== aiColor || gameState.status.type !== 'ongoing') {
        return;
      }
      
      aiThinking = true;
      document.getElementById('ai-thinking').style.display = 'block';
      updateUI();
      
      // Use setTimeout to allow UI to update before heavy computation
      setTimeout(() => {
        const difficulty = document.getElementById('ai-difficulty').value;
        const depth = getDifficultyDepth(difficulty);
        
        const result = findBestMove(gameState.board, aiColor, depth);
        
        if (result.move) {
          const move = result.move;
          const newState = makeMove(gameState, move.from, move.to, move.promotion);
          if (newState) {
            gameState = newState;
          }
        }
        
        aiThinking = false;
        document.getElementById('ai-thinking').style.display = 'none';
        selectedCell = null;
        legalMovesForSelected = [];
        updateUI();
      }, 50);
    }
    
    function updateUI() {
      drawBoard();
      
      // Update turn indicator
      const turnIndicator = document.getElementById('turn-indicator');
      turnIndicator.className = `turn-indicator ${gameState.turn}`;
      turnIndicator.textContent = gameState.status.type === 'ongoing' 
        ? `${gameState.turn.charAt(0).toUpperCase() + gameState.turn.slice(1)}'s Turn`
        : '';
      
      // Update status
      const statusEl = document.getElementById('status');
      if (gameState.status.type === 'checkmate') {
        statusEl.style.display = 'block';
        statusEl.className = 'status checkmate';
        statusEl.textContent = `Checkmate! ${gameState.status.winner.charAt(0).toUpperCase() + gameState.status.winner.slice(1)} wins!`;
      } else if (gameState.status.type === 'stalemate') {
        statusEl.style.display = 'block';
        statusEl.className = 'status stalemate';
        statusEl.textContent = 'Stalemate! Draw.';
      } else if (isInCheck(gameState.board, gameState.turn)) {
        statusEl.style.display = 'block';
        statusEl.className = 'status check';
        statusEl.textContent = 'Check!';
      } else {
        statusEl.style.display = 'none';
      }
      
      // Update move history
      const historyEl = document.getElementById('move-history');
      historyEl.innerHTML = gameState.history.map((h, i) => {
        const move = h.move;
        const fromStr = `(${move.from.q},${move.from.r})`;
        const toStr = `(${move.to.q},${move.to.r})`;
        const capture = move.captured ? 'x' : '-';
        const promotion = move.promotion ? `=${getPieceSymbol({ type: move.promotion })}` : '';
        const colorClass = move.piece.color === 'white' ? 'white-move' : 'black-move';
        return `<div class="${colorClass}">${i + 1}. ${getPieceSymbol(move.piece)}${fromStr}${capture}${toStr}${promotion}</div>`;
      }).join('');
      historyEl.scrollTop = historyEl.scrollHeight;
    }
    
    // Promotion dialog state
    let pendingPromotion = null; // { from, to }
    const promotionDialog = document.getElementById('promotion-dialog');
    
    function showPromotionDialog(from, to, color) {
      pendingPromotion = { from, to };
      
      // Set the piece color styling
      const options = document.querySelectorAll('.promotion-option');
      options.forEach(opt => {
        opt.className = `promotion-option ${color}`;
      });
      
      promotionDialog.classList.add('active');
    }
    
    function hidePromotionDialog() {
      promotionDialog.classList.remove('active');
      pendingPromotion = null;
    }
    
    // Handle promotion choice
    document.querySelectorAll('.promotion-option').forEach(option => {
      option.addEventListener('click', () => {
        if (!pendingPromotion) return;
        
        const pieceType = option.dataset.piece;
        const newState = makeMove(gameState, pendingPromotion.from, pendingPromotion.to, pieceType);
        
        if (newState) {
          gameState = newState;
        }
        
        selectedCell = null;
        legalMovesForSelected = [];
        hidePromotionDialog();
        updateUI();
        
        // Trigger AI move after player promotion
        if (aiEnabled && gameState.status.type === 'ongoing') {
          setTimeout(makeAIMove, 100);
        }
      });
    });
    
    // Event handlers
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const cell = pixelToAxial(x, y);
      
      if (!isValidCell(cell)) return;
      
      if (gameState.status.type !== 'ongoing') return;
      
      // Don't allow moves when AI is thinking or during AI's turn
      if (aiThinking || (aiEnabled && gameState.turn === aiColor)) return;
      
      if (selectedCell) {
        // Check if this is a promotion move
        if (isPromotionMove(gameState, selectedCell, cell)) {
          // Show promotion dialog
          showPromotionDialog(selectedCell, cell, gameState.turn);
          return;
        }
        
        // Try to make a move
        const newState = makeMove(gameState, selectedCell, cell);
        if (newState) {
          gameState = newState;
          selectedCell = null;
          legalMovesForSelected = [];
          updateUI();
          // Trigger AI move after player move
          if (aiEnabled && gameState.status.type === 'ongoing') {
            setTimeout(makeAIMove, 100);
          }
          return;
        } else if (coordsEqual(selectedCell, cell)) {
          // Deselect
          selectedCell = null;
          legalMovesForSelected = [];
        } else {
          // Select different piece
          const piece = getPieceAt(gameState.board, cell);
          if (piece && piece.color === gameState.turn) {
            selectedCell = cell;
            legalMovesForSelected = generateLegalMoves(gameState.board, piece, cell);
          } else {
            selectedCell = null;
            legalMovesForSelected = [];
          }
        }
      } else {
        // Select a piece
        const piece = getPieceAt(gameState.board, cell);
        if (piece && piece.color === gameState.turn) {
          selectedCell = cell;
          legalMovesForSelected = generateLegalMoves(gameState.board, piece, cell);
        }
      }
      
      updateUI();
    });
    
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const cell = pixelToAxial(x, y);
      
      if (isValidCell(cell)) {
        hoveredCell = cell;
        document.getElementById('coords-display').textContent = `Hex: (${cell.q}, ${cell.r})`;
      } else {
        hoveredCell = null;
        document.getElementById('coords-display').textContent = '';
      }
      
      drawBoard();
    });
    
    canvas.addEventListener('mouseleave', () => {
      hoveredCell = null;
      document.getElementById('coords-display').textContent = '';
      drawBoard();
    });
    
    document.getElementById('new-game-btn').addEventListener('click', () => {
      gameState = createNewGame();
      selectedCell = null;
      legalMovesForSelected = [];
      aiEnabled = false;
      document.getElementById('ai-controls').style.display = 'none';
      updateUI();
    });
    
    document.getElementById('ai-game-btn').addEventListener('click', () => {
      gameState = createNewGame();
      selectedCell = null;
      legalMovesForSelected = [];
      aiEnabled = true;
      aiColor = 'black';
      document.getElementById('ai-controls').style.display = 'block';
      updateUI();
    });
    
    document.getElementById('undo-btn').addEventListener('click', () => {
      if (aiThinking) return; // Don't undo while AI is thinking
      
      if (gameState.history.length > 0) {
        // In AI mode, undo both AI and player moves
        let movesToUndo = aiEnabled ? Math.min(2, gameState.history.length) : 1;
        
        let newHistory = gameState.history;
        let newBoard = gameState.board;
        let newTurn = gameState.turn;
        let newMoveNumber = gameState.moveNumber;
        
        for (let i = 0; i < movesToUndo; i++) {
          if (newHistory.length === 0) break;
          const lastEntry = newHistory[newHistory.length - 1];
          const previousTurn = lastEntry.move.piece.color;
          newBoard = lastEntry.previousBoard;
          newTurn = previousTurn;
          if (previousTurn === 'black') {
            newMoveNumber = Math.max(1, newMoveNumber - 1);
          }
          newHistory = newHistory.slice(0, -1);
        }
        
        gameState = {
          board: newBoard,
          turn: newTurn,
          moveNumber: newMoveNumber,
          history: newHistory,
          status: { type: 'ongoing' }
        };
        selectedCell = null;
        legalMovesForSelected = [];
        updateUI();
      }
    });
    
    // Initial render
    updateUI();
  </script>
</body>
</html>
