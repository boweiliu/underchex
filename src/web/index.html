<!DOCTYPE html>
<!--
  Underchex - Hexagonal Chess Variant
  Standalone HTML + JS implementation (no dependencies)
  
  Signed-by: agent #2 claude-sonnet-4 via opencode 20260122T02:28:36
  Edited-by: agent #4 claude-sonnet-4 via opencode 20260122T02:42:41 (added AI vs AI mode)
  Edited-by: agent #15 claude-sonnet-4 via opencode 20260122T05:23:06 (added puzzle mode)
  Edited-by: agent #39 claude-sonnet-4 via opencode 20260122T10:13:35 (added endgame tablebase)
-->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Underchex - Hexagonal Chess</title>
  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: #eee;
      margin: 0;
      padding: 20px;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    h1 {
      margin: 0 0 10px 0;
      font-size: 2em;
      color: #e94560;
    }
    
    .game-container {
      display: flex;
      gap: 30px;
      flex-wrap: wrap;
      justify-content: center;
      align-items: flex-start;
    }
    
    .board-container {
      position: relative;
    }
    
    canvas {
      border-radius: 10px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    }
    
    .info-panel {
      background: #16213e;
      padding: 20px;
      border-radius: 10px;
      min-width: 250px;
      max-width: 300px;
    }
    
    .info-panel h2 {
      margin: 0 0 15px 0;
      color: #e94560;
      font-size: 1.2em;
    }
    
    .turn-indicator {
      font-size: 1.3em;
      margin-bottom: 15px;
      padding: 10px;
      border-radius: 5px;
      text-align: center;
    }
    
    .turn-indicator.white {
      background: #f0f0f0;
      color: #333;
    }
    
    .turn-indicator.black {
      background: #333;
      color: #f0f0f0;
    }
    
    .status {
      padding: 10px;
      border-radius: 5px;
      margin-bottom: 15px;
      text-align: center;
    }
    
    .status.check {
      background: #ff6b6b;
      color: #fff;
    }
    
    .status.checkmate {
      background: #e94560;
      color: #fff;
      font-weight: bold;
    }
    
    .status.stalemate {
      background: #ffd93d;
      color: #333;
    }
    
    .move-history {
      max-height: 300px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 0.9em;
      background: #0f0f23;
      padding: 10px;
      border-radius: 5px;
      margin-bottom: 15px;
    }
    
    .move-history div {
      padding: 2px 0;
    }
    
    .move-history .white-move {
      color: #fff;
    }
    
    .move-history .black-move {
      color: #aaa;
    }
    
    button {
      background: #e94560;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1em;
      width: 100%;
      margin-bottom: 10px;
      transition: background 0.2s;
    }
    
    button:hover {
      background: #ff6b8a;
    }
    
    .legend {
      margin-top: 15px;
      font-size: 0.85em;
    }
    
    .legend h3 {
      margin: 0 0 10px 0;
      color: #e94560;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 5px;
    }
    
    .legend-symbol {
      font-size: 1.5em;
      width: 30px;
      text-align: center;
    }
    
    .coords-display {
      font-family: monospace;
      font-size: 0.8em;
      color: #888;
      margin-top: 10px;
    }
    
    /* Promotion dialog */
    .promotion-dialog {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    
    .promotion-dialog.active {
      display: flex;
    }
    
    .promotion-content {
      background: #16213e;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
    }
    
    .promotion-content h3 {
      color: #e94560;
      margin: 0 0 15px 0;
    }
    
    .promotion-options {
      display: flex;
      gap: 10px;
      justify-content: center;
    }
    
    .promotion-option {
      width: 60px;
      height: 60px;
      border-radius: 10px;
      border: 2px solid #444;
      background: #0f0f23;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.8em;
      font-weight: bold;
      transition: all 0.2s;
    }
    
    .promotion-option:hover {
      border-color: #e94560;
      background: #1a1a2e;
    }
    
    .promotion-option.white {
      background: #f0f0f0;
      color: #333;
    }
    
    .promotion-option.black {
      background: #333;
      color: #f0f0f0;
    }
    
    /* Puzzle Mode Styles */
    .puzzle-panel {
      display: none;
      margin-top: 10px;
    }
    
    .puzzle-panel.active {
      display: block;
    }
    
    .puzzle-info {
      background: #0f0f23;
      padding: 10px;
      border-radius: 5px;
      margin-bottom: 10px;
    }
    
    .puzzle-info .difficulty {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 3px;
      font-size: 0.8em;
      font-weight: bold;
      margin-left: 5px;
    }
    
    .puzzle-info .difficulty.beginner { background: #4CAF50; color: white; }
    .puzzle-info .difficulty.intermediate { background: #2196F3; color: white; }
    .puzzle-info .difficulty.advanced { background: #ff9800; color: white; }
    .puzzle-info .difficulty.expert { background: #e94560; color: white; }
    
    .puzzle-themes {
      font-size: 0.85em;
      color: #888;
      margin-top: 5px;
    }
    
    .puzzle-progress {
      margin-top: 8px;
      font-size: 0.9em;
    }
    
    .puzzle-message {
      padding: 10px;
      border-radius: 5px;
      margin-bottom: 10px;
      text-align: center;
      font-weight: bold;
    }
    
    .puzzle-message.correct {
      background: #4CAF50;
      color: white;
    }
    
    .puzzle-message.incorrect {
      background: #e94560;
      color: white;
    }
    
    .puzzle-message.solved {
      background: #ffd93d;
      color: #333;
    }
    
    .puzzle-buttons {
      display: flex;
      gap: 5px;
      margin-bottom: 10px;
    }
    
    .puzzle-buttons button {
      flex: 1;
      padding: 8px;
      font-size: 0.9em;
    }
    
    .hint-btn {
      background: #2196F3 !important;
    }
    
    .hint-btn:hover {
      background: #42a5f5 !important;
    }
    
    .next-btn {
      background: #4CAF50 !important;
    }
    
    .next-btn:hover {
      background: #66bb6a !important;
    }
    
    .puzzle-selector {
      width: 100%;
      padding: 8px;
      border-radius: 5px;
      background: #0f0f23;
      color: #eee;
      border: 1px solid #444;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <h1>Underchex</h1>
  <p style="color: #888; margin-bottom: 20px;">Hexagonal Chess Variant</p>
  
  <div class="game-container">
    <div class="board-container">
      <canvas id="board" width="600" height="600"></canvas>
    </div>
    
    <div class="info-panel">
      <h2>Game Info</h2>
      <div id="turn-indicator" class="turn-indicator white">White's Turn</div>
      <div id="status" class="status" style="display: none;"></div>
      
      <h2>Move History</h2>
      <div id="move-history" class="move-history"></div>
      
      <button id="new-game-btn">New Game (2 Player)</button>
      <button id="ai-game-btn">Play vs AI</button>
      <button id="ai-vs-ai-btn">AI vs AI</button>
      <button id="puzzle-btn">Puzzles</button>
      <button id="undo-btn">Undo Move</button>
      
      <div id="ai-controls" style="display: none; margin-top: 10px;">
        <label style="display: block; margin-bottom: 5px; color: #888;">AI Difficulty:</label>
        <select id="ai-difficulty" style="width: 100%; padding: 8px; border-radius: 5px; background: #0f0f23; color: #eee; border: 1px solid #444;">
          <option value="easy">Easy (Depth 2)</option>
          <option value="medium" selected>Medium (Depth 4)</option>
          <option value="hard">Hard (Depth 6)</option>
        </select>
        <div id="ai-thinking" style="display: none; margin-top: 10px; color: #e94560; text-align: center;">
          AI is thinking...
        </div>
      </div>
      
      <div id="ai-vs-ai-controls" style="display: none; margin-top: 10px;">
        <div style="display: flex; gap: 10px; margin-bottom: 10px;">
          <div style="flex: 1;">
            <label style="display: block; margin-bottom: 5px; color: #888; font-size: 0.9em;">White AI:</label>
            <select id="white-ai-difficulty" style="width: 100%; padding: 6px; border-radius: 5px; background: #0f0f23; color: #eee; border: 1px solid #444;">
              <option value="easy">Easy</option>
              <option value="medium" selected>Medium</option>
              <option value="hard">Hard</option>
            </select>
          </div>
          <div style="flex: 1;">
            <label style="display: block; margin-bottom: 5px; color: #888; font-size: 0.9em;">Black AI:</label>
            <select id="black-ai-difficulty" style="width: 100%; padding: 6px; border-radius: 5px; background: #0f0f23; color: #eee; border: 1px solid #444;">
              <option value="easy">Easy</option>
              <option value="medium" selected>Medium</option>
              <option value="hard">Hard</option>
            </select>
          </div>
        </div>
        <div style="display: flex; gap: 10px; margin-bottom: 10px;">
          <button id="ai-start-btn" style="flex: 1; background: #4CAF50;">Start</button>
          <button id="ai-pause-btn" style="flex: 1; background: #ff9800;">Pause</button>
          <button id="ai-step-btn" style="flex: 1; background: #2196F3;">Step</button>
        </div>
        <div style="display: flex; gap: 10px; margin-bottom: 10px;">
          <label style="display: flex; align-items: center; gap: 5px; color: #888; font-size: 0.9em;">
            <input type="range" id="ai-speed" min="50" max="2000" value="500" style="width: 100px;">
            <span id="speed-display">500ms</span>
          </label>
        </div>
        <div id="ai-vs-ai-thinking" style="display: none; margin-top: 10px; color: #e94560; text-align: center;">
          <span id="thinking-color">White</span> AI thinking...
        </div>
        <div id="ai-vs-ai-stats" style="margin-top: 10px; padding: 10px; background: #0f0f23; border-radius: 5px; font-size: 0.85em;">
          <div>Move: <span id="stats-move">0</span></div>
          <div>Eval: <span id="stats-eval">0</span></div>
          <div>Nodes: <span id="stats-nodes">0</span></div>
        </div>
      </div>
      
      <!-- Puzzle Mode Panel -->
      <div id="puzzle-panel" class="puzzle-panel">
        <select id="puzzle-selector" class="puzzle-selector">
          <option value="">Select a puzzle...</option>
        </select>
        
        <div id="puzzle-info" class="puzzle-info" style="display: none;">
          <div>
            <strong>Puzzle <span id="puzzle-number">1</span></strong>
            <span id="puzzle-difficulty" class="difficulty beginner">Beginner</span>
          </div>
          <div class="puzzle-themes">Theme: <span id="puzzle-theme">Checkmate</span></div>
          <div class="puzzle-progress">
            <span id="puzzle-to-move">White</span> to move
            <br>Move <span id="puzzle-current-move">1</span> of <span id="puzzle-total-moves">1</span>
          </div>
        </div>
        
        <div id="puzzle-message" class="puzzle-message" style="display: none;"></div>
        
        <div class="puzzle-buttons">
          <button id="puzzle-hint-btn" class="hint-btn">Hint</button>
          <button id="puzzle-retry-btn">Retry</button>
          <button id="puzzle-next-btn" class="next-btn">Next</button>
        </div>
        
        <div style="font-size: 0.85em; color: #888; text-align: center;">
          Solved: <span id="puzzles-solved">0</span> / <span id="puzzles-total">0</span>
        </div>
      </div>
      
      <div class="legend">
        <h3>Pieces</h3>
        <div class="legend-item"><span class="legend-symbol">K</span> King</div>
        <div class="legend-item"><span class="legend-symbol">Q</span> Queen</div>
        <div class="legend-item"><span class="legend-symbol">C</span> Chariot</div>
        <div class="legend-item"><span class="legend-symbol">L</span> Lance</div>
        <div class="legend-item"><span class="legend-symbol">N</span> Knight</div>
        <div class="legend-item"><span class="legend-symbol">P</span> Pawn</div>
      </div>
      
      <div id="coords-display" class="coords-display"></div>
    </div>
  </div>
  
  <!-- Promotion Dialog -->
  <div id="promotion-dialog" class="promotion-dialog">
    <div class="promotion-content">
      <h3>Choose Promotion</h3>
      <div class="promotion-options">
        <div class="promotion-option" data-piece="queen">Q</div>
        <div class="promotion-option" data-piece="chariot">C</div>
        <div class="promotion-option" data-piece="lance">L</div>
        <div class="promotion-option" data-piece="knight">N</div>
      </div>
    </div>
  </div>

  <script>
    // =========================================================================
    // UNDERCHEX GAME ENGINE (Standalone JS Implementation)
    // Signed-by: agent #2 claude-sonnet-4 via opencode 20260122T02:28:36
    // =========================================================================
    
    const BOARD_RADIUS = 4;
    
    const DIRECTIONS = {
      N:  { q:  0, r: -1 },
      S:  { q:  0, r:  1 },
      NE: { q:  1, r: -1 },
      SW: { q: -1, r:  1 },
      NW: { q: -1, r:  0 },
      SE: { q:  1, r:  0 },
    };
    
    const ALL_DIRECTIONS = ['N', 'S', 'NE', 'SW', 'NW', 'SE'];
    const DIAGONAL_DIRECTIONS = ['NE', 'NW', 'SE', 'SW'];
    const LANCE_A_DIRECTIONS = ['N', 'S', 'NW', 'SE'];
    const LANCE_B_DIRECTIONS = ['N', 'S', 'NE', 'SW'];
    
    const KNIGHT_OFFSETS = [
      { q:  1, r: -2 },
      { q: -1, r: -1 },
      { q:  2, r: -1 },
      { q:  1, r:  1 },
      { q: -1, r:  2 },
      { q: -2, r:  1 },
    ];
    
    // Utility functions
    function coordToString(coord) {
      return `${coord.q},${coord.r}`;
    }
    
    function stringToCoord(str) {
      const [q, r] = str.split(',').map(Number);
      return { q, r };
    }
    
    function coordsEqual(a, b) {
      return a.q === b.q && a.r === b.r;
    }
    
    function isValidCell(coord) {
      const { q, r } = coord;
      const s = -q - r;
      return Math.max(Math.abs(q), Math.abs(r), Math.abs(s)) <= BOARD_RADIUS;
    }
    
    function getAllCells() {
      const cells = [];
      for (let q = -BOARD_RADIUS; q <= BOARD_RADIUS; q++) {
        for (let r = -BOARD_RADIUS; r <= BOARD_RADIUS; r++) {
          const coord = { q, r };
          if (isValidCell(coord)) cells.push(coord);
        }
      }
      return cells;
    }
    
    function getNeighbor(coord, direction) {
      const delta = DIRECTIONS[direction];
      const neighbor = { q: coord.q + delta.q, r: coord.r + delta.r };
      return isValidCell(neighbor) ? neighbor : null;
    }
    
    function getRay(start, direction) {
      const cells = [];
      let current = start;
      while (true) {
        const delta = DIRECTIONS[direction];
        const next = { q: current.q + delta.q, r: current.r + delta.r };
        if (!isValidCell(next)) break;
        cells.push(next);
        current = next;
      }
      return cells;
    }
    
    function getKnightTargets(from) {
      const targets = [];
      for (const offset of KNIGHT_OFFSETS) {
        const target = { q: from.q + offset.q, r: from.r + offset.r };
        if (isValidCell(target)) targets.push(target);
      }
      return targets;
    }
    
    function getOppositeDirection(dir) {
      const opposites = { N: 'S', S: 'N', NE: 'SW', SW: 'NE', NW: 'SE', SE: 'NW' };
      return opposites[dir];
    }
    
    // Board operations
    function getPieceAt(board, coord) {
      return board.get(coordToString(coord));
    }
    
    function isOccupied(board, coord) {
      return board.has(coordToString(coord));
    }
    
    function hasEnemy(board, coord, color) {
      const piece = getPieceAt(board, coord);
      return piece && piece.color !== color;
    }
    
    function hasFriendly(board, coord, color) {
      const piece = getPieceAt(board, coord);
      return piece && piece.color === color;
    }
    
    function getForwardDirection(color) {
      return color === 'white' ? 'N' : 'S';
    }
    
    function getPawnCaptureDirections(color) {
      return color === 'white' ? ['N', 'NE', 'NW'] : ['S', 'SE', 'SW'];
    }
    
    function getPieceDirections(piece) {
      switch (piece.type) {
        case 'king':
        case 'queen':
          return ALL_DIRECTIONS;
        case 'chariot':
          return DIAGONAL_DIRECTIONS;
        case 'lance':
          return piece.variant === 'A' ? LANCE_A_DIRECTIONS : LANCE_B_DIRECTIONS;
        default:
          return [];
      }
    }
    
    function isSlider(pieceType) {
      return pieceType === 'queen' || pieceType === 'lance' || pieceType === 'chariot';
    }
    
    // Pawn promotion
    const PROMOTION_TARGETS = ['queen', 'chariot', 'lance', 'knight'];
    
    function isPromotionZone(coord, color) {
      const targetR = color === 'white' ? -BOARD_RADIUS : BOARD_RADIUS;
      return coord.r === targetR;
    }
    
    // Move generation
    function generatePseudoLegalMoves(board, piece, from) {
      const moves = [];
      
      if (piece.type === 'pawn') {
        const forwardDir = getForwardDirection(piece.color);
        const forward = getNeighbor(from, forwardDir);
        if (forward && !isOccupied(board, forward)) {
          if (isPromotionZone(forward, piece.color)) {
            for (const promotionType of PROMOTION_TARGETS) {
              moves.push({ piece, from, to: forward, promotion: promotionType });
            }
          } else {
            moves.push({ piece, from, to: forward });
          }
        }
        for (const dir of getPawnCaptureDirections(piece.color)) {
          const target = getNeighbor(from, dir);
          if (target && hasEnemy(board, target, piece.color)) {
            const captured = getPieceAt(board, target);
            if (isPromotionZone(target, piece.color)) {
              for (const promotionType of PROMOTION_TARGETS) {
                moves.push({ piece, from, to: target, captured, promotion: promotionType });
              }
            } else {
              moves.push({ piece, from, to: target, captured });
            }
          }
        }
      } else if (piece.type === 'king') {
        for (const dir of ALL_DIRECTIONS) {
          const target = getNeighbor(from, dir);
          if (target && !hasFriendly(board, target, piece.color)) {
            moves.push({ piece, from, to: target, captured: getPieceAt(board, target) });
          }
        }
      } else if (piece.type === 'knight') {
        for (const target of getKnightTargets(from)) {
          if (!hasFriendly(board, target, piece.color)) {
            moves.push({ piece, from, to: target, captured: getPieceAt(board, target) });
          }
        }
      } else {
        // Slider pieces (queen, lance, chariot)
        for (const dir of getPieceDirections(piece)) {
          for (const target of getRay(from, dir)) {
            if (hasFriendly(board, target, piece.color)) break;
            moves.push({ piece, from, to: target, captured: getPieceAt(board, target) });
            if (getPieceAt(board, target)) break;
          }
        }
      }
      
      return moves;
    }
    
    function findKing(board, color) {
      for (const [posStr, piece] of board.entries()) {
        if (piece.type === 'king' && piece.color === color) {
          return stringToCoord(posStr);
        }
      }
      return null;
    }
    
    function isAttacked(board, target, byColor) {
      // Pawn attacks
      for (const dir of getPawnCaptureDirections(byColor)) {
        const reverseDir = getOppositeDirection(dir);
        const attacker = getNeighbor(target, reverseDir);
        if (attacker) {
          const piece = getPieceAt(board, attacker);
          if (piece?.type === 'pawn' && piece.color === byColor) return true;
        }
      }
      
      // King attacks
      for (const dir of ALL_DIRECTIONS) {
        const attacker = getNeighbor(target, dir);
        if (attacker) {
          const piece = getPieceAt(board, attacker);
          if (piece?.type === 'king' && piece.color === byColor) return true;
        }
      }
      
      // Knight attacks
      for (const attackerPos of getKnightTargets(target)) {
        const piece = getPieceAt(board, attackerPos);
        if (piece?.type === 'knight' && piece.color === byColor) return true;
      }
      
      // Slider attacks
      for (const dir of ALL_DIRECTIONS) {
        for (const pos of getRay(target, dir)) {
          const piece = getPieceAt(board, pos);
          if (!piece) continue;
          if (piece.color !== byColor) break;
          const pieceDirections = getPieceDirections(piece);
          const reverseDir = getOppositeDirection(dir);
          if (pieceDirections.includes(reverseDir) && isSlider(piece.type)) return true;
          break;
        }
      }
      
      return false;
    }
    
    function isInCheck(board, color) {
      const kingPos = findKing(board, color);
      if (!kingPos) return false;
      return isAttacked(board, kingPos, color === 'white' ? 'black' : 'white');
    }
    
    function applyMove(board, move) {
      const newBoard = new Map(board);
      newBoard.delete(coordToString(move.from));
      
      // Handle promotion
      if (move.promotion) {
        const promotedPiece = {
          type: move.promotion,
          color: move.piece.color,
          ...(move.promotion === 'lance' ? { variant: 'A' } : {}),
        };
        newBoard.set(coordToString(move.to), promotedPiece);
      } else {
        newBoard.set(coordToString(move.to), move.piece);
      }
      
      return newBoard;
    }
    
    function generateLegalMoves(board, piece, from) {
      return generatePseudoLegalMoves(board, piece, from).filter(move => {
        const newBoard = applyMove(board, move);
        return !isInCheck(newBoard, piece.color);
      });
    }
    
    function generateAllLegalMoves(board, color) {
      const moves = [];
      for (const [posStr, piece] of board.entries()) {
        if (piece.color !== color) continue;
        const from = stringToCoord(posStr);
        moves.push(...generateLegalMoves(board, piece, from));
      }
      return moves;
    }
    
    // Game state
    function getStartingPosition() {
      const pieces = [];
      
      // White pieces
      pieces.push({ piece: { type: 'king', color: 'white' }, position: { q: 0, r: 4 } });
      pieces.push({ piece: { type: 'queen', color: 'white' }, position: { q: 1, r: 3 } });
      pieces.push({ piece: { type: 'chariot', color: 'white' }, position: { q: -2, r: 4 } });
      pieces.push({ piece: { type: 'chariot', color: 'white' }, position: { q: 2, r: 3 } });
      pieces.push({ piece: { type: 'lance', color: 'white', variant: 'A' }, position: { q: -1, r: 4 } });
      pieces.push({ piece: { type: 'lance', color: 'white', variant: 'B' }, position: { q: 1, r: 4 } });
      pieces.push({ piece: { type: 'knight', color: 'white' }, position: { q: -2, r: 3 } });
      pieces.push({ piece: { type: 'knight', color: 'white' }, position: { q: 2, r: 4 } });
      
      // White pawns
      for (const pos of [{ q: -3, r: 3 }, { q: -2, r: 2 }, { q: -1, r: 2 }, { q: 0, r: 2 }, { q: 1, r: 2 }, { q: 2, r: 2 }]) {
        pieces.push({ piece: { type: 'pawn', color: 'white' }, position: pos });
      }
      
      // Black pieces
      pieces.push({ piece: { type: 'king', color: 'black' }, position: { q: 0, r: -4 } });
      pieces.push({ piece: { type: 'queen', color: 'black' }, position: { q: -1, r: -3 } });
      pieces.push({ piece: { type: 'chariot', color: 'black' }, position: { q: 2, r: -4 } });
      pieces.push({ piece: { type: 'chariot', color: 'black' }, position: { q: -2, r: -3 } });
      pieces.push({ piece: { type: 'lance', color: 'black', variant: 'A' }, position: { q: 1, r: -4 } });
      pieces.push({ piece: { type: 'lance', color: 'black', variant: 'B' }, position: { q: -1, r: -4 } });
      pieces.push({ piece: { type: 'knight', color: 'black' }, position: { q: 2, r: -3 } });
      pieces.push({ piece: { type: 'knight', color: 'black' }, position: { q: -2, r: -4 } });
      
      // Black pawns
      for (const pos of [{ q: 3, r: -3 }, { q: 2, r: -2 }, { q: 1, r: -2 }, { q: 0, r: -2 }, { q: -1, r: -2 }, { q: -2, r: -2 }]) {
        pieces.push({ piece: { type: 'pawn', color: 'black' }, position: pos });
      }
      
      return pieces;
    }
    
    function createNewGame() {
      const board = new Map();
      for (const { piece, position } of getStartingPosition()) {
        board.set(coordToString(position), piece);
      }
      return {
        board,
        turn: 'white',
        moveNumber: 1,
        history: [],
        status: { type: 'ongoing' }
      };
    }
    
    function makeMove(state, from, to, promotionChoice = null) {
      if (state.status.type !== 'ongoing') return null;
      
      const piece = getPieceAt(state.board, from);
      if (!piece || piece.color !== state.turn) return null;
      
      const legalMoves = generateLegalMoves(state.board, piece, from);
      
      // Filter moves to the target cell
      let movesToTarget = legalMoves.filter(m => coordsEqual(m.to, to));
      if (movesToTarget.length === 0) return null;
      
      // Handle promotion selection
      let move;
      if (movesToTarget[0].promotion) {
        // This is a promotion move
        if (promotionChoice) {
          move = movesToTarget.find(m => m.promotion === promotionChoice);
        } else {
          // Default to queen for now (UI will handle actual choice)
          move = movesToTarget.find(m => m.promotion === 'queen');
        }
      } else {
        move = movesToTarget[0];
      }
      
      if (!move) return null;
      
      const newBoard = applyMove(state.board, move);
      const nextTurn = state.turn === 'white' ? 'black' : 'white';
      
      // Determine game status
      const opponentMoves = generateAllLegalMoves(newBoard, nextTurn);
      let status;
      if (opponentMoves.length === 0) {
        if (isInCheck(newBoard, nextTurn)) {
          status = { type: 'checkmate', winner: state.turn };
        } else {
          status = { type: 'stalemate' };
        }
      } else {
        status = { type: 'ongoing' };
      }
      
      return {
        board: newBoard,
        turn: nextTurn,
        moveNumber: state.turn === 'black' ? state.moveNumber + 1 : state.moveNumber,
        history: [...state.history, { move, previousBoard: state.board }],
        status
      };
    }
    
    // Check if a move would be a promotion
    function isPromotionMove(state, from, to) {
      const piece = getPieceAt(state.board, from);
      if (!piece || piece.type !== 'pawn') return false;
      const legalMoves = generateLegalMoves(state.board, piece, from);
      const movesToTarget = legalMoves.filter(m => coordsEqual(m.to, to));
      return movesToTarget.length > 0 && movesToTarget[0].promotion;
    }
    
    // =========================================================================
    // ENDGAME TABLEBASE MODULE
    // Provides perfect endgame play for simple endgames (KvK, KQvK, etc.)
    // Signed-by: agent #39 claude-sonnet-4 via opencode 20260122T10:13:35
    // =========================================================================
    
    // Tablebase storage: maps configuration name to tablebase entries
    const tablebases = new Map();
    
    // WDL outcomes: 'win', 'draw', 'loss' from perspective of side to move
    
    /**
     * Detect the piece configuration of a position.
     * Returns { name, strongerSide, weakerSide } or null if not supported.
     */
    function detectTablebaseConfig(board) {
      const pieces = { white: [], black: [] };
      
      for (const [posStr, piece] of board.entries()) {
        if (piece.type !== 'king') {
          pieces[piece.color].push(piece.type);
        }
      }
      
      // Determine stronger side (more material)
      let strongerSide, weakerSide;
      if (pieces.white.length >= pieces.black.length) {
        strongerSide = pieces.white.sort();
        weakerSide = pieces.black.sort();
      } else {
        strongerSide = pieces.black.sort();
        weakerSide = pieces.white.sort();
      }
      
      // Generate name: K[pieces]vK[pieces]
      const abbrev = (type) => {
        const map = { queen: 'Q', lance: 'L', chariot: 'C', knight: 'N', pawn: 'P' };
        return map[type] || type[0].toUpperCase();
      };
      
      let name = 'K' + strongerSide.map(abbrev).join('') + 'vK' + weakerSide.map(abbrev).join('');
      
      // Only support simple endgames (max 4 pieces total, weaker side has no pieces)
      const totalPieces = 2 + strongerSide.length + weakerSide.length;
      if (totalPieces > 4 || weakerSide.length > 0) {
        return null;
      }
      
      return { name, strongerSide, weakerSide };
    }
    
    /**
     * Create a position key for tablebase lookup using Zobrist-like hashing.
     */
    function getTablebaseKey(board, sideToMove) {
      // Simple hash: concatenate piece positions in sorted order
      const pieces = [];
      for (const [posStr, piece] of board.entries()) {
        pieces.push(`${piece.color[0]}${piece.type[0]}${posStr}`);
      }
      pieces.sort();
      return pieces.join('-') + '-' + sideToMove;
    }
    
    /**
     * Check if position is illegal (opponent in check = they could have captured king)
     */
    function isIllegalTablebasePosition(board, sideToMove) {
      const opponent = sideToMove === 'white' ? 'black' : 'white';
      return isInCheck(board, opponent);
    }
    
    /**
     * Generate all valid positions for a given tablebase configuration.
     */
    function* generateTablebasePositions(config) {
      const allCells = getAllCells();
      
      for (const whiteKingPos of allCells) {
        for (const blackKingPos of allCells) {
          // Kings can't be on same cell
          if (coordsEqual(whiteKingPos, blackKingPos)) continue;
          
          // Kings can't be adjacent (hex distance 1)
          const dist = hexDistance(whiteKingPos, blackKingPos);
          if (dist <= 1) continue;
          
          const remainingCells = allCells.filter(c => 
            !coordsEqual(c, whiteKingPos) && !coordsEqual(c, blackKingPos)
          );
          
          if (config.strongerSide.length === 0) {
            // KvK - just kings
            for (const sideToMove of ['white', 'black']) {
              const board = new Map();
              board.set(coordToString(whiteKingPos), { type: 'king', color: 'white' });
              board.set(coordToString(blackKingPos), { type: 'king', color: 'black' });
              if (!isIllegalTablebasePosition(board, sideToMove)) {
                yield { board, sideToMove };
              }
            }
          } else if (config.strongerSide.length === 1) {
            // K + 1 piece vs K
            const pieceType = config.strongerSide[0];
            
            for (const piecePos of remainingCells) {
              for (const sideToMove of ['white', 'black']) {
                const variants = pieceType === 'lance' ? ['A', 'B'] : [null];
                
                for (const variant of variants) {
                  const board = new Map();
                  board.set(coordToString(whiteKingPos), { type: 'king', color: 'white' });
                  board.set(coordToString(blackKingPos), { type: 'king', color: 'black' });
                  
                  const piece = variant 
                    ? { type: pieceType, color: 'white', variant }
                    : { type: pieceType, color: 'white' };
                  board.set(coordToString(piecePos), piece);
                  
                  if (!isIllegalTablebasePosition(board, sideToMove)) {
                    yield { board: new Map(board), sideToMove };
                  }
                }
              }
            }
          }
        }
      }
    }
    
    /**
     * Get terminal outcome of a position.
     * Returns { wdl, dtm } or null if not terminal.
     */
    function getTerminalOutcome(board, sideToMove) {
      const moves = generateAllLegalMoves(board, sideToMove);
      
      if (moves.length === 0) {
        if (isInCheck(board, sideToMove)) {
          return { wdl: 'loss', dtm: 0 }; // Checkmate
        }
        return { wdl: 'draw', dtm: -1 }; // Stalemate
      }
      
      return null;
    }
    
    /**
     * Generate a tablebase for a given configuration using retrograde analysis.
     */
    function generateTablebase(config) {
      const startTime = performance.now();
      
      const tablebase = {
        name: config.name,
        entries: new Map(),
        metadata: {
          generatedAt: new Date().toISOString(),
          generationTimeMs: 0,
          winCount: 0,
          drawCount: 0,
          lossCount: 0,
        }
      };
      
      // Phase 1: Generate all positions, find terminals
      const positionMap = new Map();
      const unknownPositions = new Set();
      
      for (const { board, sideToMove } of generateTablebasePositions(config)) {
        const key = getTablebaseKey(board, sideToMove);
        positionMap.set(key, { board: new Map(board), sideToMove });
        
        const terminal = getTerminalOutcome(board, sideToMove);
        if (terminal) {
          tablebase.entries.set(key, { ...terminal });
          if (terminal.wdl === 'loss') tablebase.metadata.lossCount++;
          else if (terminal.wdl === 'draw') tablebase.metadata.drawCount++;
        } else {
          unknownPositions.add(key);
        }
      }
      
      // Phase 2: Retrograde analysis
      let changed = true;
      let iteration = 0;
      const MAX_ITERATIONS = 500;
      
      while (changed && iteration < MAX_ITERATIONS) {
        changed = false;
        iteration++;
        const toResolve = [];
        
        for (const key of unknownPositions) {
          const pos = positionMap.get(key);
          if (!pos) continue;
          
          const moves = generateAllLegalMoves(pos.board, pos.sideToMove);
          let hasWinningMove = false;
          let allMovesLose = true;
          let bestMoveInfo = null;
          let maxDTM = 0;
          
          for (const move of moves) {
            const newBoard = applyMove(pos.board, move);
            const opponent = pos.sideToMove === 'white' ? 'black' : 'white';
            const newKey = getTablebaseKey(newBoard, opponent);
            const opponentEntry = tablebase.entries.get(newKey);
            
            if (!opponentEntry) {
              allMovesLose = false;
              continue;
            }
            
            if (opponentEntry.wdl === 'loss') {
              hasWinningMove = true;
              if (!bestMoveInfo || opponentEntry.dtm + 1 < bestMoveInfo.dtm) {
                bestMoveInfo = {
                  from: move.from,
                  to: move.to,
                  dtm: opponentEntry.dtm + 1,
                  promotion: move.promotion
                };
              }
            } else if (opponentEntry.wdl === 'win') {
              maxDTM = Math.max(maxDTM, opponentEntry.dtm);
            } else {
              allMovesLose = false;
            }
          }
          
          if (hasWinningMove && bestMoveInfo) {
            toResolve.push(key);
            tablebase.entries.set(key, {
              wdl: 'win',
              dtm: bestMoveInfo.dtm,
              bestMove: { from: bestMoveInfo.from, to: bestMoveInfo.to, promotion: bestMoveInfo.promotion }
            });
            tablebase.metadata.winCount++;
            changed = true;
          } else if (allMovesLose && moves.length > 0) {
            toResolve.push(key);
            tablebase.entries.set(key, {
              wdl: 'loss',
              dtm: maxDTM + 1
            });
            tablebase.metadata.lossCount++;
            changed = true;
          }
        }
        
        for (const key of toResolve) {
          unknownPositions.delete(key);
        }
      }
      
      // Phase 3: Remaining unknown = draws
      for (const key of unknownPositions) {
        tablebase.entries.set(key, { wdl: 'draw', dtm: -1 });
        tablebase.metadata.drawCount++;
      }
      
      tablebase.size = tablebase.entries.size;
      tablebase.metadata.generationTimeMs = performance.now() - startTime;
      
      return tablebase;
    }
    
    /**
     * Probe the tablebase for a position.
     */
    function probeTablebase(board, sideToMove) {
      const config = detectTablebaseConfig(board);
      if (!config) return { found: false };
      
      const tablebase = tablebases.get(config.name);
      if (!tablebase) return { found: false };
      
      const key = getTablebaseKey(board, sideToMove);
      const entry = tablebase.entries.get(key);
      
      if (entry) {
        return { found: true, entry, tablebaseName: config.name };
      }
      
      return { found: false };
    }
    
    /**
     * Get the tablebase move for a position.
     */
    function getTablebaseMove(board, sideToMove) {
      const result = probeTablebase(board, sideToMove);
      
      if (!result.found || !result.entry?.bestMove) {
        return null;
      }
      
      const { from, to, promotion } = result.entry.bestMove;
      const piece = getPieceAt(board, from);
      if (!piece) return null;
      
      return {
        from,
        to,
        piece,
        captured: getPieceAt(board, to),
        promotion
      };
    }
    
    /**
     * Get tablebase evaluation score.
     * Returns +CHECKMATE_VALUE - DTM for wins, 0 for draws, -CHECKMATE_VALUE + DTM for losses.
     */
    function getTablebaseScore(board, sideToMove) {
      const result = probeTablebase(board, sideToMove);
      if (!result.found || !result.entry) return null;
      
      switch (result.entry.wdl) {
        case 'win': return CHECKMATE_VALUE - result.entry.dtm;
        case 'draw': return 0;
        case 'loss': return -CHECKMATE_VALUE + result.entry.dtm;
      }
    }
    
    /**
     * Check if a position is a tablebase endgame.
     */
    function isTablebaseEndgame(board) {
      const config = detectTablebaseConfig(board);
      return config !== null && tablebases.has(config.name);
    }
    
    /**
     * Initialize common tablebases (KvK, KQvK, etc.)
     */
    function initializeTablebases() {
      const configs = [
        { strongerSide: [], weakerSide: [], name: 'KvK' },
        { strongerSide: ['queen'], weakerSide: [], name: 'KQvK' },
        { strongerSide: ['lance'], weakerSide: [], name: 'KLvK' },
        { strongerSide: ['chariot'], weakerSide: [], name: 'KCvK' },
        { strongerSide: ['knight'], weakerSide: [], name: 'KNvK' },
      ];
      
      for (const config of configs) {
        console.log(`Generating tablebase: ${config.name}...`);
        const tablebase = generateTablebase(config);
        tablebases.set(config.name, tablebase);
        console.log(`  ${tablebase.size} positions in ${tablebase.metadata.generationTimeMs.toFixed(0)}ms`);
      }
      
      console.log(`Tablebases initialized: ${tablebases.size} endgames loaded`);
    }
    
    /**
     * Get tablebase statistics for display.
     */
    function getTablebaseStatistics() {
      let totalEntries = 0;
      const stats = [];
      
      for (const [name, tb] of tablebases) {
        totalEntries += tb.size;
        stats.push({
          name,
          size: tb.size,
          wins: tb.metadata.winCount,
          draws: tb.metadata.drawCount,
          losses: tb.metadata.lossCount,
          generationTimeMs: tb.metadata.generationTimeMs
        });
      }
      
      return { totalEntries, tablebases: stats };
    }
    
    // =========================================================================
    // AI ENGINE
    // Signed-by: agent #3 claude-sonnet-4 via opencode 20260122T02:35:07
    // Edited-by: agent #39 claude-sonnet-4 via opencode 20260122T10:13:35 (integrated tablebase)
    // =========================================================================
    
    const PIECE_VALUES = {
      pawn: 100,
      knight: 300,
      lance: 450,
      chariot: 450,
      queen: 900,
      king: 0
    };
    
    const CHECKMATE_VALUE = 100000;
    
    function hexDistance(a, b) {
      const dq = Math.abs(a.q - b.q);
      const dr = Math.abs(a.r - b.r);
      const ds = Math.abs((-a.q - a.r) - (-b.q - b.r));
      return Math.max(dq, dr, ds);
    }
    
    function getCentralityBonus(coord) {
      const distanceFromCenter = hexDistance(coord, { q: 0, r: 0 });
      return (BOARD_RADIUS - distanceFromCenter) * 5;
    }
    
    function getPawnAdvancementBonus(coord, color) {
      const targetR = color === 'white' ? -BOARD_RADIUS : BOARD_RADIUS;
      const startR = color === 'white' ? BOARD_RADIUS : -BOARD_RADIUS;
      const totalDistance = Math.abs(targetR - startR);
      const distanceFromStart = Math.abs(coord.r - startR);
      const progress = distanceFromStart / totalDistance;
      return Math.floor(progress * progress * 50);
    }
    
    function getPiecePositionBonus(piece, coord) {
      let bonus = getCentralityBonus(coord);
      if (piece.type === 'pawn') {
        bonus += getPawnAdvancementBonus(coord, piece.color);
      }
      if (piece.type === 'king') {
        const distFromCenter = hexDistance(coord, { q: 0, r: 0 });
        if (distFromCenter < 2) bonus -= 30;
      }
      return bonus;
    }
    
    function evaluateMaterial(board) {
      let score = 0;
      for (const [posStr, piece] of board.entries()) {
        const value = PIECE_VALUES[piece.type];
        const coord = stringToCoord(posStr);
        const positionBonus = getPiecePositionBonus(piece, coord);
        const totalValue = value + positionBonus;
        score += piece.color === 'white' ? totalValue : -totalValue;
      }
      return score;
    }
    
    function evaluateMobility(board, color) {
      const moves = generateAllLegalMoves(board, color);
      return moves.length * 2;
    }
    
    function evaluatePosition(board) {
      let score = evaluateMaterial(board);
      score += evaluateMobility(board, 'white') - evaluateMobility(board, 'black');
      if (isInCheck(board, 'white')) score -= 50;
      if (isInCheck(board, 'black')) score += 50;
      return score;
    }
    
    function estimateMoveValue(move) {
      let score = 0;
      if (move.captured) {
        score += PIECE_VALUES[move.captured.type] * 10 - PIECE_VALUES[move.piece.type];
      }
      if (move.promotion) {
        score += PIECE_VALUES[move.promotion] - PIECE_VALUES.pawn;
      }
      score += getCentralityBonus(move.to);
      return score;
    }
    
    function orderMoves(moves) {
      return [...moves].sort((a, b) => estimateMoveValue(b) - estimateMoveValue(a));
    }
    
    function alphaBeta(board, depth, alpha, beta, maximizing, stats) {
      stats.nodesSearched++;
      
      const color = maximizing ? 'white' : 'black';
      
      // Probe tablebase for endgame positions
      const tbScore = getTablebaseScore(board, color);
      if (tbScore !== null) {
        // Adjust score based on perspective
        return maximizing ? tbScore : -tbScore;
      }
      
      const moves = generateAllLegalMoves(board, color);
      
      if (moves.length === 0) {
        if (isInCheck(board, color)) {
          return maximizing ? -CHECKMATE_VALUE + stats.nodesSearched : CHECKMATE_VALUE - stats.nodesSearched;
        }
        return 0; // Stalemate
      }
      
      if (depth === 0) {
        return evaluatePosition(board);
      }
      
      const orderedMoves = orderMoves(moves);
      
      if (maximizing) {
        let maxEval = -Infinity;
        for (const move of orderedMoves) {
          const newBoard = applyMove(board, move);
          const evalScore = alphaBeta(newBoard, depth - 1, alpha, beta, false, stats);
          maxEval = Math.max(maxEval, evalScore);
          alpha = Math.max(alpha, evalScore);
          if (beta <= alpha) {
            stats.cutoffs++;
            break;
          }
        }
        return maxEval;
      } else {
        let minEval = Infinity;
        for (const move of orderedMoves) {
          const newBoard = applyMove(board, move);
          const evalScore = alphaBeta(newBoard, depth - 1, alpha, beta, true, stats);
          minEval = Math.min(minEval, evalScore);
          beta = Math.min(beta, evalScore);
          if (beta <= alpha) {
            stats.cutoffs++;
            break;
          }
        }
        return minEval;
      }
    }
    
    function findBestMove(board, color, depth) {
      const stats = { nodesSearched: 0, cutoffs: 0, usedTablebase: false };
      
      // First, probe the tablebase for endgame positions
      if (isTablebaseEndgame(board)) {
        const tbMove = getTablebaseMove(board, color);
        const tbScore = getTablebaseScore(board, color);
        
        if (tbMove) {
          stats.usedTablebase = true;
          return { move: tbMove, score: tbScore || 0, stats };
        }
        
        // If no best move in tablebase but it's an endgame, use tablebase score if available
        // Fall through to search but with tablebase-aware evaluation
      }
      
      const moves = generateAllLegalMoves(board, color);
      
      if (moves.length === 0) {
        return { move: null, score: 0, stats };
      }
      
      const maximizing = color === 'white';
      const orderedMoves = orderMoves(moves);
      
      let bestMove = orderedMoves[0];
      let bestScore = maximizing ? -Infinity : Infinity;
      let alpha = -Infinity;
      let beta = Infinity;
      
      for (const move of orderedMoves) {
        const newBoard = applyMove(board, move);
        const evalScore = alphaBeta(newBoard, depth - 1, alpha, beta, !maximizing, stats);
        
        if (maximizing) {
          if (evalScore > bestScore) {
            bestScore = evalScore;
            bestMove = move;
          }
          alpha = Math.max(alpha, evalScore);
        } else {
          if (evalScore < bestScore) {
            bestScore = evalScore;
            bestMove = move;
          }
          beta = Math.min(beta, evalScore);
        }
      }
      
      return { move: bestMove, score: bestScore, stats };
    }
    
    function getDifficultyDepth(difficulty) {
      switch (difficulty) {
        case 'easy': return 2;
        case 'medium': return 4;
        case 'hard': return 6;
        default: return 4;
      }
    }
    
    // =========================================================================
    // UI RENDERING
    // =========================================================================
    
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    
    const HEX_SIZE = 32;
    const CENTER_X = canvas.width / 2;
    const CENTER_Y = canvas.height / 2;
    
    let gameState = createNewGame();
    let selectedCell = null;
    let legalMovesForSelected = [];
    let hoveredCell = null;
    let aiEnabled = false;
    let aiColor = 'black'; // AI always plays black when enabled
    let aiThinking = false;
    
    // Convert axial to pixel coordinates
    function axialToPixel(q, r) {
      const x = HEX_SIZE * (Math.sqrt(3) * q + Math.sqrt(3) / 2 * r) + CENTER_X;
      const y = HEX_SIZE * (3 / 2 * r) + CENTER_Y;
      return { x, y };
    }
    
    // Convert pixel to axial coordinates
    function pixelToAxial(px, py) {
      const x = px - CENTER_X;
      const y = py - CENTER_Y;
      const q = (Math.sqrt(3) / 3 * x - 1 / 3 * y) / HEX_SIZE;
      const r = (2 / 3 * y) / HEX_SIZE;
      return hexRound(q, r);
    }
    
    function hexRound(q, r) {
      const s = -q - r;
      let rq = Math.round(q);
      let rr = Math.round(r);
      let rs = Math.round(s);
      
      const qDiff = Math.abs(rq - q);
      const rDiff = Math.abs(rr - r);
      const sDiff = Math.abs(rs - s);
      
      if (qDiff > rDiff && qDiff > sDiff) {
        rq = -rr - rs;
      } else if (rDiff > sDiff) {
        rr = -rq - rs;
      }
      
      return { q: rq, r: rr };
    }
    
    // Draw a hexagon
    function drawHex(x, y, size, fill, stroke) {
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = Math.PI / 180 * (60 * i - 30);
        const hx = x + size * Math.cos(angle);
        const hy = y + size * Math.sin(angle);
        if (i === 0) ctx.moveTo(hx, hy);
        else ctx.lineTo(hx, hy);
      }
      ctx.closePath();
      if (fill) {
        ctx.fillStyle = fill;
        ctx.fill();
      }
      if (stroke) {
        ctx.strokeStyle = stroke;
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }
    
    // Get cell color based on coordinate (3-color scheme for hex grids)
    function getCellColor(q, r) {
      const mod = ((q - r) % 3 + 3) % 3;
      const colors = ['#2d5016', '#3d6b22', '#4d7b2e'];
      return colors[mod];
    }
    
    // Get piece symbol
    function getPieceSymbol(piece) {
      const symbols = {
        king: 'K',
        queen: 'Q',
        chariot: 'C',
        lance: 'L',
        knight: 'N',
        pawn: 'P'
      };
      return symbols[piece.type] || '?';
    }
    
    // Draw the entire board
    function drawBoard() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      const cells = getAllCells();
      
      // Draw cells
      for (const cell of cells) {
        const { x, y } = axialToPixel(cell.q, cell.r);
        let fillColor = getCellColor(cell.q, cell.r);
        
        // Highlight selected cell
        if (selectedCell && coordsEqual(cell, selectedCell)) {
          fillColor = '#ffcc00';
        }
        // Highlight legal move destinations
        else if (legalMovesForSelected.some(m => coordsEqual(m.to, cell))) {
          const isCapture = getPieceAt(gameState.board, cell);
          fillColor = isCapture ? '#ff6b6b' : '#6bff6b';
        }
        // Highlight hovered cell
        else if (hoveredCell && coordsEqual(cell, hoveredCell)) {
          fillColor = '#5a8a3a';
        }
        
        drawHex(x, y, HEX_SIZE, fillColor, '#1a1a2e');
        
        // Draw coordinate for debugging (optional - can be toggled)
        // ctx.fillStyle = '#ffffff44';
        // ctx.font = '8px sans-serif';
        // ctx.textAlign = 'center';
        // ctx.fillText(`${cell.q},${cell.r}`, x, y + 15);
      }
      
      // Draw pieces
      for (const cell of cells) {
        const piece = getPieceAt(gameState.board, cell);
        if (piece) {
          const { x, y } = axialToPixel(cell.q, cell.r);
          
          // Draw piece background
          ctx.beginPath();
          ctx.arc(x, y, HEX_SIZE * 0.6, 0, Math.PI * 2);
          ctx.fillStyle = piece.color === 'white' ? '#f0f0f0' : '#333';
          ctx.fill();
          ctx.strokeStyle = piece.color === 'white' ? '#ccc' : '#555';
          ctx.lineWidth = 2;
          ctx.stroke();
          
          // Draw piece symbol
          ctx.fillStyle = piece.color === 'white' ? '#333' : '#f0f0f0';
          ctx.font = `bold ${HEX_SIZE * 0.8}px sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(getPieceSymbol(piece), x, y);
        }
      }
      
      // Draw check indicator on king
      if (isInCheck(gameState.board, gameState.turn)) {
        const kingPos = findKing(gameState.board, gameState.turn);
        if (kingPos) {
          const { x, y } = axialToPixel(kingPos.q, kingPos.r);
          ctx.beginPath();
          ctx.arc(x, y, HEX_SIZE * 0.8, 0, Math.PI * 2);
          ctx.strokeStyle = '#ff0000';
          ctx.lineWidth = 3;
          ctx.stroke();
        }
      }
    }
    
    // Make AI move
    function makeAIMove() {
      if (!aiEnabled || gameState.turn !== aiColor || gameState.status.type !== 'ongoing') {
        return;
      }
      
      aiThinking = true;
      document.getElementById('ai-thinking').style.display = 'block';
      updateUI();
      
      // Use setTimeout to allow UI to update before heavy computation
      setTimeout(() => {
        const difficulty = document.getElementById('ai-difficulty').value;
        const depth = getDifficultyDepth(difficulty);
        
        const result = findBestMove(gameState.board, aiColor, depth);
        
        if (result.move) {
          const move = result.move;
          const newState = makeMove(gameState, move.from, move.to, move.promotion);
          if (newState) {
            gameState = newState;
          }
        }
        
        aiThinking = false;
        document.getElementById('ai-thinking').style.display = 'none';
        selectedCell = null;
        legalMovesForSelected = [];
        updateUI();
      }, 50);
    }
    
    function updateUI() {
      drawBoard();
      
      // Update turn indicator
      const turnIndicator = document.getElementById('turn-indicator');
      turnIndicator.className = `turn-indicator ${gameState.turn}`;
      turnIndicator.textContent = gameState.status.type === 'ongoing' 
        ? `${gameState.turn.charAt(0).toUpperCase() + gameState.turn.slice(1)}'s Turn`
        : '';
      
      // Update status
      const statusEl = document.getElementById('status');
      if (gameState.status.type === 'checkmate') {
        statusEl.style.display = 'block';
        statusEl.className = 'status checkmate';
        statusEl.textContent = `Checkmate! ${gameState.status.winner.charAt(0).toUpperCase() + gameState.status.winner.slice(1)} wins!`;
      } else if (gameState.status.type === 'stalemate') {
        statusEl.style.display = 'block';
        statusEl.className = 'status stalemate';
        statusEl.textContent = 'Stalemate! Draw.';
      } else if (isInCheck(gameState.board, gameState.turn)) {
        statusEl.style.display = 'block';
        statusEl.className = 'status check';
        statusEl.textContent = 'Check!';
      } else {
        statusEl.style.display = 'none';
      }
      
      // Update move history
      const historyEl = document.getElementById('move-history');
      historyEl.innerHTML = gameState.history.map((h, i) => {
        const move = h.move;
        const fromStr = `(${move.from.q},${move.from.r})`;
        const toStr = `(${move.to.q},${move.to.r})`;
        const capture = move.captured ? 'x' : '-';
        const promotion = move.promotion ? `=${getPieceSymbol({ type: move.promotion })}` : '';
        const colorClass = move.piece.color === 'white' ? 'white-move' : 'black-move';
        return `<div class="${colorClass}">${i + 1}. ${getPieceSymbol(move.piece)}${fromStr}${capture}${toStr}${promotion}</div>`;
      }).join('');
      historyEl.scrollTop = historyEl.scrollHeight;
    }
    
    // Promotion dialog state
    let pendingPromotion = null; // { from, to }
    const promotionDialog = document.getElementById('promotion-dialog');
    
    function showPromotionDialog(from, to, color) {
      pendingPromotion = { from, to };
      
      // Set the piece color styling
      const options = document.querySelectorAll('.promotion-option');
      options.forEach(opt => {
        opt.className = `promotion-option ${color}`;
      });
      
      promotionDialog.classList.add('active');
    }
    
    function hidePromotionDialog() {
      promotionDialog.classList.remove('active');
      pendingPromotion = null;
    }
    
    // Handle promotion choice
    document.querySelectorAll('.promotion-option').forEach(option => {
      option.addEventListener('click', () => {
        if (!pendingPromotion) return;
        
        const pieceType = option.dataset.piece;
        const newState = makeMove(gameState, pendingPromotion.from, pendingPromotion.to, pieceType);
        
        if (newState) {
          gameState = newState;
        }
        
        selectedCell = null;
        legalMovesForSelected = [];
        hidePromotionDialog();
        updateUI();
        
        // Trigger AI move after player promotion
        if (aiEnabled && gameState.status.type === 'ongoing') {
          setTimeout(makeAIMove, 100);
        }
      });
    });
    
    // Event handlers
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const cell = pixelToAxial(x, y);
      
      if (!isValidCell(cell)) return;
      
      if (gameState.status.type !== 'ongoing') return;
      
      // Don't allow moves when AI is thinking or during AI's turn
      if (aiThinking || (aiEnabled && gameState.turn === aiColor)) return;
      
      if (selectedCell) {
        // Check if this is a promotion move
        if (isPromotionMove(gameState, selectedCell, cell)) {
          // Show promotion dialog
          showPromotionDialog(selectedCell, cell, gameState.turn);
          return;
        }
        
        // Try to make a move
        const newState = makeMove(gameState, selectedCell, cell);
        if (newState) {
          gameState = newState;
          selectedCell = null;
          legalMovesForSelected = [];
          updateUI();
          // Trigger AI move after player move
          if (aiEnabled && gameState.status.type === 'ongoing') {
            setTimeout(makeAIMove, 100);
          }
          return;
        } else if (coordsEqual(selectedCell, cell)) {
          // Deselect
          selectedCell = null;
          legalMovesForSelected = [];
        } else {
          // Select different piece
          const piece = getPieceAt(gameState.board, cell);
          if (piece && piece.color === gameState.turn) {
            selectedCell = cell;
            legalMovesForSelected = generateLegalMoves(gameState.board, piece, cell);
          } else {
            selectedCell = null;
            legalMovesForSelected = [];
          }
        }
      } else {
        // Select a piece
        const piece = getPieceAt(gameState.board, cell);
        if (piece && piece.color === gameState.turn) {
          selectedCell = cell;
          legalMovesForSelected = generateLegalMoves(gameState.board, piece, cell);
        }
      }
      
      updateUI();
    });
    
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const cell = pixelToAxial(x, y);
      
      if (isValidCell(cell)) {
        hoveredCell = cell;
        document.getElementById('coords-display').textContent = `Hex: (${cell.q}, ${cell.r})`;
      } else {
        hoveredCell = null;
        document.getElementById('coords-display').textContent = '';
      }
      
      drawBoard();
    });
    
    canvas.addEventListener('mouseleave', () => {
      hoveredCell = null;
      document.getElementById('coords-display').textContent = '';
      drawBoard();
    });
    
    document.getElementById('new-game-btn').addEventListener('click', () => {
      gameState = createNewGame();
      selectedCell = null;
      legalMovesForSelected = [];
      aiEnabled = false;
      aiVsAiEnabled = false;
      aiVsAiRunning = false;
      if (aiVsAiTimeoutId) {
        clearTimeout(aiVsAiTimeoutId);
        aiVsAiTimeoutId = null;
      }
      // Exit puzzle mode if active
      if (typeof puzzleMode !== 'undefined' && puzzleMode) {
        puzzleMode = false;
        currentPuzzle = null;
        puzzleBoard = null;
        document.getElementById('puzzle-panel').classList.remove('active');
      }
      document.getElementById('ai-controls').style.display = 'none';
      document.getElementById('ai-vs-ai-controls').style.display = 'none';
      updateUI();
    });
    
    document.getElementById('ai-game-btn').addEventListener('click', () => {
      gameState = createNewGame();
      selectedCell = null;
      legalMovesForSelected = [];
      aiEnabled = true;
      aiVsAiEnabled = false;
      aiColor = 'black';
      document.getElementById('ai-controls').style.display = 'block';
      document.getElementById('ai-vs-ai-controls').style.display = 'none';
      updateUI();
    });
    
    // =========================================================================
    // AI VS AI MODE
    // Signed-by: agent #4 claude-sonnet-4 via opencode 20260122T02:42:41
    // =========================================================================
    
    let aiVsAiEnabled = false;
    let aiVsAiRunning = false;
    let aiVsAiTimeoutId = null;
    let totalNodesSearched = 0;
    
    function updateAiVsAiStats(moveNum, evalScore, nodes) {
      document.getElementById('stats-move').textContent = moveNum;
      document.getElementById('stats-eval').textContent = evalScore > 0 ? `+${evalScore}` : evalScore;
      document.getElementById('stats-nodes').textContent = nodes.toLocaleString();
    }
    
    function makeAiVsAiMove() {
      if (!aiVsAiEnabled || !aiVsAiRunning || gameState.status.type !== 'ongoing') {
        return;
      }
      
      // Show thinking indicator
      document.getElementById('ai-vs-ai-thinking').style.display = 'block';
      document.getElementById('thinking-color').textContent = gameState.turn.charAt(0).toUpperCase() + gameState.turn.slice(1);
      
      // Use setTimeout to allow UI to update
      setTimeout(() => {
        const whiteDiff = document.getElementById('white-ai-difficulty').value;
        const blackDiff = document.getElementById('black-ai-difficulty').value;
        const difficulty = gameState.turn === 'white' ? whiteDiff : blackDiff;
        const depth = getDifficultyDepth(difficulty);
        
        const result = findBestMove(gameState.board, gameState.turn, depth);
        
        if (result.move) {
          const move = result.move;
          const newState = makeMove(gameState, move.from, move.to, move.promotion);
          if (newState) {
            gameState = newState;
            totalNodesSearched += result.stats.nodesSearched;
            updateAiVsAiStats(
              gameState.history.length,
              result.score,
              totalNodesSearched
            );
          }
        }
        
        document.getElementById('ai-vs-ai-thinking').style.display = 'none';
        selectedCell = null;
        legalMovesForSelected = [];
        updateUI();
        
        // Schedule next move if game is ongoing
        if (aiVsAiRunning && gameState.status.type === 'ongoing') {
          const speed = parseInt(document.getElementById('ai-speed').value);
          aiVsAiTimeoutId = setTimeout(makeAiVsAiMove, speed);
        } else if (gameState.status.type !== 'ongoing') {
          aiVsAiRunning = false;
          document.getElementById('ai-start-btn').textContent = 'Restart';
        }
      }, 50);
    }
    
    document.getElementById('ai-vs-ai-btn').addEventListener('click', () => {
      gameState = createNewGame();
      selectedCell = null;
      legalMovesForSelected = [];
      aiEnabled = false;
      aiVsAiEnabled = true;
      aiVsAiRunning = false;
      totalNodesSearched = 0;
      
      if (aiVsAiTimeoutId) {
        clearTimeout(aiVsAiTimeoutId);
        aiVsAiTimeoutId = null;
      }
      
      document.getElementById('ai-controls').style.display = 'none';
      document.getElementById('ai-vs-ai-controls').style.display = 'block';
      document.getElementById('ai-start-btn').textContent = 'Start';
      updateAiVsAiStats(0, 0, 0);
      updateUI();
    });
    
    document.getElementById('ai-start-btn').addEventListener('click', () => {
      if (gameState.status.type !== 'ongoing') {
        // Restart game
        gameState = createNewGame();
        selectedCell = null;
        legalMovesForSelected = [];
        totalNodesSearched = 0;
        updateAiVsAiStats(0, 0, 0);
        updateUI();
      }
      
      aiVsAiRunning = true;
      document.getElementById('ai-start-btn').textContent = 'Running...';
      makeAiVsAiMove();
    });
    
    document.getElementById('ai-pause-btn').addEventListener('click', () => {
      aiVsAiRunning = false;
      if (aiVsAiTimeoutId) {
        clearTimeout(aiVsAiTimeoutId);
        aiVsAiTimeoutId = null;
      }
      document.getElementById('ai-vs-ai-thinking').style.display = 'none';
      document.getElementById('ai-start-btn').textContent = gameState.status.type === 'ongoing' ? 'Resume' : 'Restart';
    });
    
    document.getElementById('ai-step-btn').addEventListener('click', () => {
      if (gameState.status.type !== 'ongoing') return;
      
      aiVsAiRunning = false;
      if (aiVsAiTimeoutId) {
        clearTimeout(aiVsAiTimeoutId);
        aiVsAiTimeoutId = null;
      }
      
      // Make a single move
      document.getElementById('ai-vs-ai-thinking').style.display = 'block';
      document.getElementById('thinking-color').textContent = gameState.turn.charAt(0).toUpperCase() + gameState.turn.slice(1);
      
      setTimeout(() => {
        const whiteDiff = document.getElementById('white-ai-difficulty').value;
        const blackDiff = document.getElementById('black-ai-difficulty').value;
        const difficulty = gameState.turn === 'white' ? whiteDiff : blackDiff;
        const depth = getDifficultyDepth(difficulty);
        
        const result = findBestMove(gameState.board, gameState.turn, depth);
        
        if (result.move) {
          const move = result.move;
          const newState = makeMove(gameState, move.from, move.to, move.promotion);
          if (newState) {
            gameState = newState;
            totalNodesSearched += result.stats.nodesSearched;
            updateAiVsAiStats(
              gameState.history.length,
              result.score,
              totalNodesSearched
            );
          }
        }
        
        document.getElementById('ai-vs-ai-thinking').style.display = 'none';
        document.getElementById('ai-start-btn').textContent = gameState.status.type === 'ongoing' ? 'Resume' : 'Restart';
        selectedCell = null;
        legalMovesForSelected = [];
        updateUI();
      }, 50);
    });
    
    document.getElementById('ai-speed').addEventListener('input', (e) => {
      document.getElementById('speed-display').textContent = `${e.target.value}ms`;
    });
    
    document.getElementById('undo-btn').addEventListener('click', () => {
      if (aiThinking) return; // Don't undo while AI is thinking
      if (puzzleMode) return; // No undo in puzzle mode
      
      if (gameState.history.length > 0) {
        // In AI mode, undo both AI and player moves
        let movesToUndo = aiEnabled ? Math.min(2, gameState.history.length) : 1;
        
        let newHistory = gameState.history;
        let newBoard = gameState.board;
        let newTurn = gameState.turn;
        let newMoveNumber = gameState.moveNumber;
        
        for (let i = 0; i < movesToUndo; i++) {
          if (newHistory.length === 0) break;
          const lastEntry = newHistory[newHistory.length - 1];
          const previousTurn = lastEntry.move.piece.color;
          newBoard = lastEntry.previousBoard;
          newTurn = previousTurn;
          if (previousTurn === 'black') {
            newMoveNumber = Math.max(1, newMoveNumber - 1);
          }
          newHistory = newHistory.slice(0, -1);
        }
        
        gameState = {
          board: newBoard,
          turn: newTurn,
          moveNumber: newMoveNumber,
          history: newHistory,
          status: { type: 'ongoing' }
        };
        selectedCell = null;
        legalMovesForSelected = [];
        updateUI();
      }
    });
    
    // =========================================================================
    // PUZZLE MODE
    // Signed-by: agent #15 claude-sonnet-4 via opencode 20260122T05:23:06
    // =========================================================================
    
    let puzzleMode = false;
    let currentPuzzle = null;
    let currentPuzzleMoveIndex = 0;
    let puzzleBoard = null;
    let puzzleSolved = false;
    let puzzlesSolvedCount = 0;
    let hintLevel = 0; // 0 = no hint, 1 = piece, 2 = from square, 3 = full move
    
    // Pre-defined puzzles for the standalone web UI
    // Each puzzle has: position (pieces), toMove, solution (moves), themes, difficulty
    const PUZZLES = [
      // Puzzle 1: Mate in 1 - Queen captures to deliver mate
      {
        id: 'puzzle_1',
        name: 'Mate in 1',
        difficulty: 'beginner',
        themes: ['checkmate'],
        toMove: 'white',
        position: [
          { pos: '0,-4', piece: { type: 'king', color: 'black' } },
          { pos: '1,-4', piece: { type: 'pawn', color: 'black' } },
          { pos: '-1,-3', piece: { type: 'pawn', color: 'black' } },
          { pos: '0,4', piece: { type: 'king', color: 'white' } },
          { pos: '2,-2', piece: { type: 'queen', color: 'white' } },
        ],
        solution: [
          { from: {q:2,r:-2}, to: {q:0,r:-2}, pieceType: 'queen' }
        ]
      },
      // Puzzle 2: Fork - Knight attacks king and queen
      {
        id: 'puzzle_2',
        name: 'Knight Fork',
        difficulty: 'beginner',
        themes: ['fork', 'winning_capture'],
        toMove: 'white',
        position: [
          { pos: '0,-4', piece: { type: 'king', color: 'black' } },
          { pos: '3,-3', piece: { type: 'queen', color: 'black' } },
          { pos: '0,4', piece: { type: 'king', color: 'white' } },
          { pos: '0,0', piece: { type: 'knight', color: 'white' } },
        ],
        solution: [
          { from: {q:0,r:0}, to: {q:1,r:-2}, pieceType: 'knight' }
        ]
      },
      // Puzzle 3: Back rank mate with chariot
      {
        id: 'puzzle_3',
        name: 'Back Rank Mate',
        difficulty: 'beginner',
        themes: ['checkmate'],
        toMove: 'white',
        position: [
          { pos: '0,-4', piece: { type: 'king', color: 'black' } },
          { pos: '-1,-3', piece: { type: 'pawn', color: 'black' } },
          { pos: '0,-3', piece: { type: 'pawn', color: 'black' } },
          { pos: '1,-4', piece: { type: 'pawn', color: 'black' } },
          { pos: '0,4', piece: { type: 'king', color: 'white' } },
          { pos: '3,1', piece: { type: 'chariot', color: 'white' } },
        ],
        solution: [
          { from: {q:3,r:1}, to: {q:2,r:-3}, pieceType: 'chariot' }
        ]
      },
      // Puzzle 4: Win the queen with discovered attack
      {
        id: 'puzzle_4',
        name: 'Discovered Attack',
        difficulty: 'intermediate',
        themes: ['winning_capture', 'tactical'],
        toMove: 'white',
        position: [
          { pos: '0,-4', piece: { type: 'king', color: 'black' } },
          { pos: '-2,0', piece: { type: 'queen', color: 'black' } },
          { pos: '0,4', piece: { type: 'king', color: 'white' } },
          { pos: '0,0', piece: { type: 'lance', color: 'white', variant: 'A' } },
          { pos: '-1,0', piece: { type: 'knight', color: 'white' } },
        ],
        solution: [
          { from: {q:-1,r:0}, to: {q:0,r:-2}, pieceType: 'knight' }, // Check with knight, lance attacks queen
          { from: {q:0,r:-4}, to: {q:-1,r:-3}, pieceType: 'king' }, // King moves
          { from: {q:0,r:0}, to: {q:-2,r:0}, pieceType: 'lance' }, // Win the queen
        ]
      },
      // Puzzle 5: Promotion threat
      {
        id: 'puzzle_5',
        name: 'Pawn Promotion',
        difficulty: 'intermediate',
        themes: ['promotion'],
        toMove: 'white',
        position: [
          { pos: '0,-4', piece: { type: 'king', color: 'black' } },
          { pos: '0,4', piece: { type: 'king', color: 'white' } },
          { pos: '2,-3', piece: { type: 'pawn', color: 'white' } },
        ],
        solution: [
          { from: {q:2,r:-3}, to: {q:2,r:-4}, pieceType: 'pawn', promotion: 'queen' }
        ]
      },
      // Puzzle 6: Mate in 2 with queen and lance
      {
        id: 'puzzle_6',
        name: 'Mate in 2',
        difficulty: 'intermediate',
        themes: ['checkmate'],
        toMove: 'white',
        position: [
          { pos: '0,-4', piece: { type: 'king', color: 'black' } },
          { pos: '0,-3', piece: { type: 'pawn', color: 'black' } },
          { pos: '0,4', piece: { type: 'king', color: 'white' } },
          { pos: '3,-1', piece: { type: 'queen', color: 'white' } },
          { pos: '-2,-2', piece: { type: 'lance', color: 'white', variant: 'A' } },
        ],
        solution: [
          { from: {q:3,r:-1}, to: {q:1,r:-3}, pieceType: 'queen' }, // Check
          { from: {q:0,r:-4}, to: {q:-1,r:-4}, pieceType: 'king' }, // Only move
          { from: {q:-2,r:-2}, to: {q:-2,r:-4}, pieceType: 'lance' } // Mate!
        ]
      },
      // Puzzle 7: Defensive - only move to avoid mate
      {
        id: 'puzzle_7',
        name: 'Find the Defense',
        difficulty: 'intermediate',
        themes: ['defensive'],
        toMove: 'black',
        position: [
          { pos: '0,-4', piece: { type: 'king', color: 'black' } },
          { pos: '2,-2', piece: { type: 'lance', color: 'black', variant: 'B' } },
          { pos: '0,4', piece: { type: 'king', color: 'white' } },
          { pos: '0,-2', piece: { type: 'queen', color: 'white' } },
        ],
        solution: [
          { from: {q:2,r:-2}, to: {q:0,r:-2}, pieceType: 'lance' } // Block the queen
        ]
      },
      // Puzzle 8: Complex mate in 2
      {
        id: 'puzzle_8',
        name: 'Queen Sacrifice',
        difficulty: 'advanced',
        themes: ['checkmate', 'tactical'],
        toMove: 'white',
        position: [
          { pos: '1,-4', piece: { type: 'king', color: 'black' } },
          { pos: '2,-4', piece: { type: 'chariot', color: 'black' } },
          { pos: '0,4', piece: { type: 'king', color: 'white' } },
          { pos: '0,-2', piece: { type: 'queen', color: 'white' } },
          { pos: '-2,-2', piece: { type: 'lance', color: 'white', variant: 'A' } },
        ],
        solution: [
          { from: {q:0,r:-2}, to: {q:2,r:-4}, pieceType: 'queen' }, // Sacrifice queen
          { from: {q:1,r:-4}, to: {q:2,r:-4}, pieceType: 'king' }, // King takes
          { from: {q:-2,r:-2}, to: {q:-2,r:-4}, pieceType: 'lance' } // Lance mates
        ]
      },
    ];
    
    // Load puzzle position into board
    function loadPuzzlePosition(puzzle) {
      const board = new Map();
      for (const { pos, piece } of puzzle.position) {
        board.set(pos, piece);
      }
      return board;
    }
    
    // Check if a move matches the expected puzzle solution move
    function checkPuzzleMove(from, to, promotionChoice) {
      if (!currentPuzzle || puzzleSolved) return false;
      
      const expectedMove = currentPuzzle.solution[currentPuzzleMoveIndex];
      if (!expectedMove) return false;
      
      const isCorrect = 
        from.q === expectedMove.from.q &&
        from.r === expectedMove.from.r &&
        to.q === expectedMove.to.q &&
        to.r === expectedMove.to.r;
      
      // Also check promotion if expected
      if (expectedMove.promotion && promotionChoice !== expectedMove.promotion) {
        return false;
      }
      
      return isCorrect;
    }
    
    // Apply puzzle move and handle opponent response
    function applyPuzzleMove(from, to, promotionChoice) {
      const piece = getPieceAt(puzzleBoard, from);
      if (!piece) return;
      
      // Check if this is correct
      if (!checkPuzzleMove(from, to, promotionChoice)) {
        showPuzzleMessage('Incorrect. Try again!', 'incorrect');
        hintLevel = 0;
        return;
      }
      
      // Apply the move
      puzzleBoard = applyMove(puzzleBoard, {
        piece,
        from,
        to,
        captured: getPieceAt(puzzleBoard, to),
        promotion: promotionChoice
      });
      
      currentPuzzleMoveIndex++;
      hintLevel = 0;
      
      // Check if puzzle is solved
      if (currentPuzzleMoveIndex >= currentPuzzle.solution.length) {
        puzzleSolved = true;
        puzzlesSolvedCount++;
        showPuzzleMessage('Puzzle solved!', 'solved');
        updatePuzzleUI();
        return;
      }
      
      showPuzzleMessage('Correct!', 'correct');
      
      // Opponent's response (if any)
      setTimeout(() => {
        if (currentPuzzleMoveIndex < currentPuzzle.solution.length) {
          const opponentMove = currentPuzzle.solution[currentPuzzleMoveIndex];
          const opponentPiece = getPieceAt(puzzleBoard, opponentMove.from);
          
          if (opponentPiece) {
            puzzleBoard = applyMove(puzzleBoard, {
              piece: opponentPiece,
              from: opponentMove.from,
              to: opponentMove.to,
              captured: getPieceAt(puzzleBoard, opponentMove.to),
              promotion: opponentMove.promotion
            });
            currentPuzzleMoveIndex++;
          }
          
          // Check if puzzle is now solved (after opponent move)
          if (currentPuzzleMoveIndex >= currentPuzzle.solution.length) {
            puzzleSolved = true;
            puzzlesSolvedCount++;
            showPuzzleMessage('Puzzle solved!', 'solved');
          } else {
            hidePuzzleMessage();
          }
        }
        updatePuzzleUI();
        drawBoardForPuzzle();
      }, 500);
    }
    
    // Show puzzle message
    function showPuzzleMessage(text, type) {
      const msgEl = document.getElementById('puzzle-message');
      msgEl.textContent = text;
      msgEl.className = `puzzle-message ${type}`;
      msgEl.style.display = 'block';
    }
    
    function hidePuzzleMessage() {
      document.getElementById('puzzle-message').style.display = 'none';
    }
    
    // Update puzzle UI
    function updatePuzzleUI() {
      if (!currentPuzzle) return;
      
      document.getElementById('puzzle-number').textContent = currentPuzzle.id.replace('puzzle_', '');
      document.getElementById('puzzle-difficulty').textContent = currentPuzzle.difficulty.charAt(0).toUpperCase() + currentPuzzle.difficulty.slice(1);
      document.getElementById('puzzle-difficulty').className = `difficulty ${currentPuzzle.difficulty}`;
      document.getElementById('puzzle-theme').textContent = currentPuzzle.themes.join(', ');
      document.getElementById('puzzle-to-move').textContent = currentPuzzle.toMove.charAt(0).toUpperCase() + currentPuzzle.toMove.slice(1);
      document.getElementById('puzzle-current-move').textContent = Math.floor(currentPuzzleMoveIndex / 2) + 1;
      document.getElementById('puzzle-total-moves').textContent = Math.ceil(currentPuzzle.solution.length / 2);
      document.getElementById('puzzles-solved').textContent = puzzlesSolvedCount;
      document.getElementById('puzzles-total').textContent = PUZZLES.length;
      document.getElementById('puzzle-info').style.display = 'block';
    }
    
    // Draw board for puzzle mode
    function drawBoardForPuzzle() {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      const cells = getAllCells();
      
      for (const cell of cells) {
        const { x, y } = axialToPixel(cell.q, cell.r);
        let fillColor = getCellColor(cell.q, cell.r);
        
        if (selectedCell && coordsEqual(cell, selectedCell)) {
          fillColor = '#ffcc00';
        } else if (legalMovesForSelected.some(m => coordsEqual(m.to, cell))) {
          const isCapture = getPieceAt(puzzleBoard, cell);
          fillColor = isCapture ? '#ff6b6b' : '#6bff6b';
        } else if (hoveredCell && coordsEqual(cell, hoveredCell)) {
          fillColor = '#5a8a3a';
        }
        
        drawHex(x, y, HEX_SIZE, fillColor, '#1a1a2e');
      }
      
      // Draw pieces
      for (const cell of cells) {
        const piece = getPieceAt(puzzleBoard, cell);
        if (piece) {
          const { x, y } = axialToPixel(cell.q, cell.r);
          
          ctx.beginPath();
          ctx.arc(x, y, HEX_SIZE * 0.6, 0, Math.PI * 2);
          ctx.fillStyle = piece.color === 'white' ? '#f0f0f0' : '#333';
          ctx.fill();
          ctx.strokeStyle = piece.color === 'white' ? '#ccc' : '#555';
          ctx.lineWidth = 2;
          ctx.stroke();
          
          ctx.fillStyle = piece.color === 'white' ? '#333' : '#f0f0f0';
          ctx.font = `bold ${HEX_SIZE * 0.8}px sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(getPieceSymbol(piece), x, y);
        }
      }
      
      // Draw check indicator
      const toMove = currentPuzzle ? currentPuzzle.toMove : 'white';
      const currentTurn = currentPuzzleMoveIndex % 2 === 0 ? toMove : (toMove === 'white' ? 'black' : 'white');
      if (isInCheck(puzzleBoard, currentTurn)) {
        const kingPos = findKing(puzzleBoard, currentTurn);
        if (kingPos) {
          const { x, y } = axialToPixel(kingPos.q, kingPos.r);
          ctx.beginPath();
          ctx.arc(x, y, HEX_SIZE * 0.8, 0, Math.PI * 2);
          ctx.strokeStyle = '#ff0000';
          ctx.lineWidth = 3;
          ctx.stroke();
        }
      }
    }
    
    // Load a specific puzzle
    function loadPuzzle(puzzleIndex) {
      if (puzzleIndex < 0 || puzzleIndex >= PUZZLES.length) return;
      
      currentPuzzle = PUZZLES[puzzleIndex];
      currentPuzzleMoveIndex = 0;
      puzzleSolved = false;
      hintLevel = 0;
      puzzleBoard = loadPuzzlePosition(currentPuzzle);
      selectedCell = null;
      legalMovesForSelected = [];
      
      hidePuzzleMessage();
      updatePuzzleUI();
      drawBoardForPuzzle();
      
      // Update turn indicator for puzzle mode
      const turnIndicator = document.getElementById('turn-indicator');
      turnIndicator.className = `turn-indicator ${currentPuzzle.toMove}`;
      turnIndicator.textContent = `${currentPuzzle.toMove.charAt(0).toUpperCase() + currentPuzzle.toMove.slice(1)} to Move`;
    }
    
    // Initialize puzzle selector
    function initPuzzleSelector() {
      const selector = document.getElementById('puzzle-selector');
      selector.innerHTML = '<option value="">Select a puzzle...</option>';
      
      PUZZLES.forEach((puzzle, i) => {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `${i + 1}. ${puzzle.name} (${puzzle.difficulty})`;
        selector.appendChild(option);
      });
    }
    
    // Puzzle button click handler
    document.getElementById('puzzle-btn').addEventListener('click', () => {
      // Enter puzzle mode
      puzzleMode = true;
      aiEnabled = false;
      aiVsAiEnabled = false;
      aiVsAiRunning = false;
      
      if (aiVsAiTimeoutId) {
        clearTimeout(aiVsAiTimeoutId);
        aiVsAiTimeoutId = null;
      }
      
      document.getElementById('ai-controls').style.display = 'none';
      document.getElementById('ai-vs-ai-controls').style.display = 'none';
      document.getElementById('puzzle-panel').classList.add('active');
      document.getElementById('move-history').innerHTML = '<div style="color:#888;">Puzzle mode - Find the best move!</div>';
      
      initPuzzleSelector();
      document.getElementById('puzzles-total').textContent = PUZZLES.length;
      
      // Load first puzzle by default
      if (PUZZLES.length > 0) {
        document.getElementById('puzzle-selector').value = '0';
        loadPuzzle(0);
      }
    });
    
    // Puzzle selector change
    document.getElementById('puzzle-selector').addEventListener('change', (e) => {
      const idx = parseInt(e.target.value);
      if (!isNaN(idx)) {
        loadPuzzle(idx);
      }
    });
    
    // Hint button
    document.getElementById('puzzle-hint-btn').addEventListener('click', () => {
      if (!currentPuzzle || puzzleSolved) return;
      
      const expectedMove = currentPuzzle.solution[currentPuzzleMoveIndex];
      if (!expectedMove) return;
      
      hintLevel++;
      let hintText;
      
      if (hintLevel === 1) {
        hintText = `Move your ${expectedMove.pieceType}`;
      } else if (hintLevel === 2) {
        hintText = `Move from (${expectedMove.from.q}, ${expectedMove.from.r})`;
      } else {
        hintText = `Move ${expectedMove.pieceType} from (${expectedMove.from.q},${expectedMove.from.r}) to (${expectedMove.to.q},${expectedMove.to.r})`;
        if (expectedMove.promotion) {
          hintText += ` and promote to ${expectedMove.promotion}`;
        }
      }
      
      showPuzzleMessage(hintText, 'correct');
    });
    
    // Retry button
    document.getElementById('puzzle-retry-btn').addEventListener('click', () => {
      if (!currentPuzzle) return;
      
      currentPuzzleMoveIndex = 0;
      puzzleSolved = false;
      hintLevel = 0;
      puzzleBoard = loadPuzzlePosition(currentPuzzle);
      selectedCell = null;
      legalMovesForSelected = [];
      
      hidePuzzleMessage();
      updatePuzzleUI();
      drawBoardForPuzzle();
    });
    
    // Next puzzle button
    document.getElementById('puzzle-next-btn').addEventListener('click', () => {
      const selector = document.getElementById('puzzle-selector');
      const currentIdx = parseInt(selector.value);
      const nextIdx = (currentIdx + 1) % PUZZLES.length;
      selector.value = nextIdx;
      loadPuzzle(nextIdx);
    });
    
    // New game button should exit puzzle mode
    const originalNewGameHandler = document.getElementById('new-game-btn').onclick;
    document.getElementById('new-game-btn').addEventListener('click', () => {
      if (puzzleMode) {
        puzzleMode = false;
        currentPuzzle = null;
        puzzleBoard = null;
        document.getElementById('puzzle-panel').classList.remove('active');
      }
    });
    
    // AI game button should exit puzzle mode
    document.getElementById('ai-game-btn').addEventListener('click', () => {
      if (puzzleMode) {
        puzzleMode = false;
        currentPuzzle = null;
        puzzleBoard = null;
        document.getElementById('puzzle-panel').classList.remove('active');
      }
    }, true); // Use capture to run before existing handler
    
    // AI vs AI button should exit puzzle mode
    document.getElementById('ai-vs-ai-btn').addEventListener('click', () => {
      if (puzzleMode) {
        puzzleMode = false;
        currentPuzzle = null;
        puzzleBoard = null;
        document.getElementById('puzzle-panel').classList.remove('active');
      }
    }, true);
    
    // Override canvas click for puzzle mode
    const originalCanvasClickHandler = canvas.onclick;
    canvas.addEventListener('click', (e) => {
      if (!puzzleMode || !currentPuzzle || puzzleSolved) return;
      
      e.stopImmediatePropagation(); // Prevent other handlers
      
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const cell = pixelToAxial(x, y);
      
      if (!isValidCell(cell)) return;
      
      // Determine whose turn it is in the puzzle
      const toMove = currentPuzzle.toMove;
      const currentTurn = currentPuzzleMoveIndex % 2 === 0 ? toMove : (toMove === 'white' ? 'black' : 'white');
      
      // Only allow moving if it's player's turn (even moves for the puzzle solver)
      if (currentPuzzleMoveIndex % 2 !== 0) return;
      
      if (selectedCell) {
        // Check if this is a promotion move
        const piece = getPieceAt(puzzleBoard, selectedCell);
        if (piece && piece.type === 'pawn' && isPromotionZone(cell, piece.color)) {
          const legalMoves = generateLegalMoves(puzzleBoard, piece, selectedCell);
          const movesToTarget = legalMoves.filter(m => coordsEqual(m.to, cell));
          
          if (movesToTarget.length > 0 && movesToTarget[0].promotion) {
            // Check what promotion is expected
            const expectedMove = currentPuzzle.solution[currentPuzzleMoveIndex];
            if (expectedMove && expectedMove.promotion) {
              // Auto-select the expected promotion for validation
              applyPuzzleMove(selectedCell, cell, expectedMove.promotion);
            } else {
              // Show promotion dialog
              showPromotionDialog(selectedCell, cell, piece.color);
            }
            selectedCell = null;
            legalMovesForSelected = [];
            drawBoardForPuzzle();
            return;
          }
        }
        
        // Try to make a move
        if (piece) {
          const legalMoves = generateLegalMoves(puzzleBoard, piece, selectedCell);
          const validMove = legalMoves.find(m => coordsEqual(m.to, cell));
          
          if (validMove) {
            applyPuzzleMove(selectedCell, cell, null);
            selectedCell = null;
            legalMovesForSelected = [];
            drawBoardForPuzzle();
            return;
          }
        }
        
        // Deselect or select different piece
        if (coordsEqual(selectedCell, cell)) {
          selectedCell = null;
          legalMovesForSelected = [];
        } else {
          const newPiece = getPieceAt(puzzleBoard, cell);
          if (newPiece && newPiece.color === currentTurn) {
            selectedCell = cell;
            legalMovesForSelected = generateLegalMoves(puzzleBoard, newPiece, cell);
          } else {
            selectedCell = null;
            legalMovesForSelected = [];
          }
        }
      } else {
        // Select a piece
        const piece = getPieceAt(puzzleBoard, cell);
        if (piece && piece.color === currentTurn) {
          selectedCell = cell;
          legalMovesForSelected = generateLegalMoves(puzzleBoard, piece, cell);
        }
      }
      
      drawBoardForPuzzle();
    }, true); // Use capture phase
    
    // Handle promotion dialog for puzzle mode
    const originalPromotionHandler = document.querySelectorAll('.promotion-option');
    document.querySelectorAll('.promotion-option').forEach(option => {
      option.addEventListener('click', (e) => {
        if (!puzzleMode || !pendingPromotion) return;
        
        e.stopImmediatePropagation();
        
        const pieceType = option.dataset.piece;
        applyPuzzleMove(pendingPromotion.from, pendingPromotion.to, pieceType);
        hidePromotionDialog();
        drawBoardForPuzzle();
      }, true);
    });
    
    // =========================================================================
    // INITIALIZATION
    // Signed-by: agent #39 claude-sonnet-4 via opencode 20260122T10:13:35
    // =========================================================================
    
    // Initialize tablebases on page load
    // Using setTimeout to avoid blocking initial render
    let tablebasesLoaded = false;
    
    setTimeout(() => {
      console.log('Initializing endgame tablebases...');
      const startTime = performance.now();
      initializeTablebases();
      tablebasesLoaded = true;
      const elapsed = performance.now() - startTime;
      console.log(`All tablebases loaded in ${elapsed.toFixed(0)}ms`);
      
      // Show tablebase stats
      const stats = getTablebaseStatistics();
      console.log('=== Tablebase Statistics ===');
      for (const tb of stats.tablebases) {
        console.log(`${tb.name}: ${tb.size} positions (W:${tb.wins} D:${tb.draws} L:${tb.losses})`);
      }
      console.log(`Total: ${stats.totalEntries} positions`);
    }, 100);
    
    // Initial render
    updateUI();
  </script>
</body>
</html>
